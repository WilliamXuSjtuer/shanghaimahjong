<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä¸Šæµ·æ•²éº» - å“ˆçµè§„åˆ™ | AIå°æ¸¸æˆå¹³å°</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&family=Ma+Shan+Zheng&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- é¢„åŠ è½½å…³é”®èµ„æº -->
    <link rel="preload" href="img/majiang.png" as="image" type="image/png">
    <style>
        :root {
            --table-green: #1a5c3a;
            --table-dark: #0d3321;
            --gold: #d4af37;
            --gold-light: #f4d03f;
            --tile-bg: #f5f0e1;
            --tile-border: #c9b896;
            --red: #c0392b;
            --blue: #2980b9;
            --green: #27ae60;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Noto Sans SC', sans-serif;
            background: radial-gradient(ellipse at center, var(--table-green) 0%, var(--table-dark) 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        /* å¼€å§‹ç•Œé¢ */
        .start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            text-align: center;
        }

        .game-logo {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 4rem;
            color: var(--gold);
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .game-subtitle {
            font-size: 1.2rem;
            color: rgba(255,255,255,0.8);
            margin-bottom: 20px;
        }
        
        .scoreboard-preview {
            background: linear-gradient(135deg, rgba(243,156,18,0.3) 0%, rgba(211,84,0,0.3) 100%);
            border: 2px solid var(--gold);
            border-radius: 15px;
            padding: 15px 30px;
            margin-bottom: 20px;
            display: inline-block;
            font-size: 1.1rem;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .scoreboard-preview .score-big {
            font-size: 2rem;
            font-weight: bold;
            color: var(--gold);
        }

        .menu-container {
            background: rgba(0,0,0,0.4);
            border: 2px solid var(--gold);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 100%;
        }

        /* æ€§åˆ«é€‰æ‹©å™¨ */
        .gender-select-group {
            margin-bottom: 20px;
        }
        
        .gender-selector {
            display: flex;
            gap: 10px;
        }
        
        .gender-btn {
            flex: 1;
            padding: 12px 20px;
            font-size: 1rem;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .gender-btn:hover {
            border-color: var(--gold);
            color: #fff;
        }
        
        .gender-btn.active {
            border-color: var(--gold);
            background: linear-gradient(135deg, rgba(212,175,55,0.3) 0%, rgba(184,134,11,0.3) 100%);
            color: var(--gold);
            font-weight: bold;
        }
        
        .gender-btn i {
            font-size: 1.2rem;
        }

        .menu-btn {
            display: block;
            width: 100%;
            padding: 18px 30px;
            margin: 15px 0;
            font-size: 1.3rem;
            font-family: 'Ma Shan Zheng', cursive;
            background: linear-gradient(135deg, var(--gold) 0%, #b8860b 100%);
            color: #1a1a1a;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(212,175,55,0.4);
        }

        .menu-btn.secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 2px solid var(--gold);
        }

        /* æ¸¸æˆç•Œé¢ */
        .game-container {
            display: none;
            min-height: 100vh;
            padding: 10px;
        }

        /* é¡¶éƒ¨çŠ¶æ€æ  */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-icon {
            width: 30px;
            height: 30px;
            background: var(--gold);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #1a1a1a;
            font-weight: bold;
        }

        .back-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        /* éº»å°†æ¡Œé¢ */
        .mahjong-table { 
            background: radial-gradient(ellipse at center, #2d8b57 0%, #1a5c3a 50%, #0d3321 100%);
            border: 8px solid #5d4037;
            border-radius: 20px;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.3), 0 10px 30px rgba(0,0,0,0.5);
            padding: 20px;
            position: relative;
            min-height: 500px;
        }

        /* ç©å®¶åŒºåŸŸ */
        .player-area {
            position: relative;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .player-avatar {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, var(--gold) 0%, #b8860b 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            border: 3px solid white;
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .player-wind {
            background: var(--red);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .current-turn {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(212,175,55,0.7); }
            50% { box-shadow: 0 0 0 10px rgba(212,175,55,0); }
        }

        /* æ‰‹ç‰ŒåŒºåŸŸ */
        .hand-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 4px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            min-height: 100px;
        }

        /* éº»å°†ç‰Œ - ä½¿ç”¨ç²¾çµå›¾ */
        .tile { 
            width: 50px;
            height: 70px;
            background-color: #f5f0e1;
            background-image: url('img/majiang.png');
            background-repeat: no-repeat;
            border: 2px solid var(--tile-border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            position: relative;
            user-select: none;
        }

        .tile:hover {
            transform: translateY(-8px);
            box-shadow: 2px 8px 15px rgba(0,0,0,0.4);
        }

        .tile.selected {
            transform: translateY(-15px);
            border-color: var(--gold);
            box-shadow: 0 0 20px rgba(212,175,55,0.6);
        }
        
        /* åˆšæ‘¸çš„ç‰Œ - çªå‡ºæ˜¾ç¤º */
        .tile.new-tile {
            margin-left: 15px;
            border-color: #3498db;
            box-shadow: 0 0 15px rgba(52,152,219,0.8);
            animation: newTilePulse 1s ease-in-out infinite;
        }
        
        @keyframes newTilePulse {
            0%, 100% { box-shadow: 0 0 15px rgba(52,152,219,0.8); }
            50% { box-shadow: 0 0 25px rgba(52,152,219,1); }
        }

        .tile.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        /* å°ç‰Œï¼ˆå¯¹æ‰‹å’Œç‰Œæ± ï¼‰ */
        .tile.small {
            width: 32px;
            height: 45px;
        }
        
        /* ç‰Œé¢åŠ è½½ä¸­çŠ¶æ€ */
        .tile.loading {
            background-image: none;
            background: linear-gradient(135deg, #e0d8c8 25%, #f5f0e1 50%, #e0d8c8 75%);
            background-size: 200% 100%;
            animation: tileLoading 1s ease-in-out infinite;
        }
        
        @keyframes tileLoading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        /* ç²¾çµå›¾åŠ è½½å®Œæˆåç§»é™¤åŠ è½½çŠ¶æ€ */
        body.sprites-loaded .tile.loading {
            animation: none;
            background: #f5f0e1;
        }

        .tile.back {
            background-image: none;
            background: linear-gradient(135deg, #2e7d32 0%, #1b5e20 100%);
            border-color: #1b5e20;
        }

        .tile.back::after {
            content: 'ğŸ€«';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            opacity: 0.5;
        }

        .tile.small.back::after {
            font-size: 0.8rem;
        }

        /* æ–‡å­—å¤‡ç”¨æ˜¾ç¤ºï¼ˆç²¾çµå›¾åŠ è½½å¤±è´¥æ—¶ï¼‰ */
        .tile-text {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .tile.text-mode {
            background-image: none !important;
            background: linear-gradient(180deg, #fff 0%, var(--tile-bg) 100%);
        }

        .tile.text-mode .tile-text {
            display: flex;
        }

        .tile-value {
            font-size: 1.6rem;
            font-weight: bold;
            line-height: 1;
        }

        .tile-suit {
            font-size: 0.65rem;
            color: #666;
            margin-top: 2px;
        }

        /* ç‰Œçš„é¢œè‰²ï¼ˆæ–‡å­—æ¨¡å¼ï¼‰ */
        .tile.wan .tile-value { color: var(--red); }
        .tile.tiao .tile-value { color: var(--green); }
        .tile.tong .tile-value { color: var(--blue); }
        .tile.feng .tile-value { color: #333; }
        .tile.hua .tile-value { color: #9b59b6; }

        /* å¯¹æ‰‹åŒºåŸŸ */
        .opponents-area {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .opponent {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
        }

        .opponent-hand {
            display: flex;
            justify-content: center;
            gap: 2px;
            flex-wrap: wrap;
        }

        /* ä¸­å¤®å‡ºç‰ŒåŒºåŸŸ */
        .center-area {
            background: rgba(0,0,0,0.15);
            border-radius: 15px;
            padding: 15px;
            margin: 15px 0;
        }

        .discard-zone {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 8px;
            margin: 5px 0;
        }

        .discard-zone .zone-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 5px;
            text-align: center;
        }

        .discard-zone .discards {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            justify-content: center;
            min-height: 35px;
        }

        .discard-sides {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .discard-zone.left,
        .discard-zone.right {
            flex: 1;
        }

        .discard-zone.bottom {
            border: 1px solid var(--gold);
            background: rgba(212,175,55,0.1);
        }

        .discard-zone.bottom .zone-label {
            color: var(--gold);
        }

        /* æ“ä½œæŒ‰é’® */
        .action-panel {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 12px 25px;
            font-size: 1.1rem;
            font-family: 'Ma Shan Zheng', cursive;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 80px;
        }

        .action-btn.primary {
            background: linear-gradient(135deg, var(--gold) 0%, #b8860b 100%);
            color: #1a1a1a;
        }

        .action-btn.secondary {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .action-btn.danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .action-btn.success {
            background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
            color: white;
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .action-btn:not(:disabled):hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        /* æç¤ºæ¡† */
        .action-hints {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .hint-btn {
            padding: 15px 30px;
            font-size: 1.2rem;
            font-family: 'Ma Shan Zheng', cursive;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: 3px solid white;
            border-radius: 15px;
            cursor: pointer;
            animation: bounce 0.5s ease infinite;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        /* æ¶ˆæ¯å¼¹çª— */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%);
            border: 3px solid var(--gold);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            animation: modalIn 0.3s ease;
        }

        @keyframes modalIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal-title {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 2.5rem;
            color: var(--gold);
            margin-bottom: 20px;
        }

        .modal-message {
            font-size: 1.2rem;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        /* è§„åˆ™é¡µé¢ */
        .rules-container {
            display: none;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .rules-container.active {
            display: block;
        }

        .rules-card {
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--gold);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
        }

        .rules-title {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 20px;
            text-align: center;
        }

        .rules-section {
            margin-bottom: 20px;
        }

        .rules-section h3 {
            color: var(--gold-light);
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .rules-section p, .rules-section li {
            color: rgba(255,255,255,0.9);
            line-height: 1.8;
        }

        .rules-section ul {
            padding-left: 20px;
        }

        /* å‰¯éœ²æ˜¾ç¤º */
        .melds-area {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .meld-group {
            display: flex;
            gap: 2px;
            background: rgba(255,255,255,0.1);
            padding: 5px;
            border-radius: 5px;
        }

        /* å“åº”å¼ */
        @media (max-width: 768px) {
            .game-logo { font-size: 2.5rem; }
            .tile { width: 38px; height: 55px; }
            .tile-value { font-size: 1.4rem; }
            .tile.small { width: 25px; height: 35px; }
            .tile.small .tile-value { font-size: 0.9rem; }
            .opponents-area { grid-template-columns: 1fr; }
            .status-bar { flex-wrap: wrap; gap: 10px; }
            .action-btn { padding: 10px 18px; font-size: 1rem; }
        }

        /* èŠ±ç‰ŒåŒºåŸŸ */
        .flowers-area {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
        }

        .flower-tile {
            width: 35px;
            height: 50px;
        }
    </style>
</head>
<body>
    <!-- å¼€å§‹ç•Œé¢ -->
    <div class="start-screen" id="startScreen">
        <h1 class="game-logo">ğŸ€„ ä¸Šæµ·æ•²éº»</h1>
        <p class="game-subtitle">å“ˆçµè§„åˆ™ Â· ä¸èƒ½åƒç‰Œ Â· é—¨æ¸…ç¿»å€</p>
        
        <!-- ç§¯åˆ†æ¦œæ¦‚è§ˆ -->
        <div id="scoreboardPreview" class="scoreboard-preview"></div>
        
        <div class="menu-container">
            <!-- æ€§åˆ«è¯­éŸ³é€‰æ‹© -->
            <div class="gender-select-group">
                <label style="color: var(--gold); margin-bottom: 10px; display: block;">
                    <i class="fas fa-venus-mars"></i> é€‰æ‹©è¯­éŸ³
                </label>
                <div class="gender-selector">
                    <button type="button" class="gender-btn active" id="genderFemale" onclick="selectGender('female')">
                        <i class="fas fa-venus"></i> å¥³å£°
                    </button>
                    <button type="button" class="gender-btn" id="genderMale" onclick="selectGender('male')">
                        <i class="fas fa-mars"></i> ç”·å£°
                    </button>
                </div>
            </div>
            
            <!-- åŠ è½½çŠ¶æ€æç¤º -->
            <p id="loadingText" style="text-align: center; margin-bottom: 10px; color: rgba(255,255,255,0.7); font-size: 0.9rem;">åŠ è½½ä¸­...</p>
            
            <button class="menu-btn game-start" onclick="startGame('easy')" disabled style="opacity: 0.6;">
                <i class="fas fa-play"></i> å¼€å§‹æ¸¸æˆï¼ˆç®€å•ï¼‰
            </button>
            <button class="menu-btn game-start" onclick="startGame('normal')" disabled style="opacity: 0.6;">
                <i class="fas fa-gamepad"></i> å¼€å§‹æ¸¸æˆï¼ˆæ™®é€šï¼‰
            </button>
            <button class="menu-btn game-start" onclick="startGame('hard')" disabled style="opacity: 0.6;">
                <i class="fas fa-trophy"></i> å¼€å§‹æ¸¸æˆï¼ˆå›°éš¾ï¼‰
            </button>
            <button class="menu-btn" onclick="window.location.href='../mahjong-multiplayer/index.html'" style="background: linear-gradient(135deg, #e74c3c, #c0392b);">
                <i class="fas fa-users"></i> å¤šäººè”æœºï¼ˆé‚€è¯·å¥½å‹ï¼‰
            </button>
            <button class="menu-btn secondary" onclick="showRules()">
                <i class="fas fa-book"></i> æ¸¸æˆè§„åˆ™
            </button>
            <button class="menu-btn secondary" onclick="showFullScoreboard()">
                <i class="fas fa-trophy"></i> å®Œæ•´ç§¯åˆ†æ¦œ
            </button>
            <button class="menu-btn secondary" onclick="window.location.href='../../index.html'">
                <i class="fas fa-home"></i> è¿”å›ä¸»é¡µ
            </button>
        </div>
        </div>

    <!-- è§„åˆ™é¡µé¢ -->
    <div class="rules-container" id="rulesContainer">
        <div class="rules-card">
            <h2 class="rules-title">ğŸ€„ ä¸Šæµ·æ•²éº»è§„åˆ™ï¼ˆå“ˆçµç‰ˆï¼‰</h2>
            
            <div class="rules-section">
                <h3>ğŸ“œ åŸºæœ¬è§„åˆ™</h3>
                <ul>
                    <li>ä½¿ç”¨144å¼ ç‰Œï¼ˆä¸‡ã€ç­’ã€æ¡å„36å¼  + ä¸œå—è¥¿åŒ—ä¸­å‘ç™½å„4å¼  + èŠ±ç‰Œ8å¼ ï¼‰</li>
                    <li>å››äººå¯¹æˆ˜ï¼Œæ¯äººèµ·æ‰‹13å¼ ç‰Œ</li>
                    <li>è½®æµæ‘¸ç‰Œã€æ‰“ç‰Œï¼Œç›®æ ‡æ˜¯å‡‘æˆèƒ¡ç‰Œç‰Œå‹</li>
                </ul>
            </div>
            
            <div class="rules-section">
                <h3>ğŸŒ¸ èŠ±ç‰Œè§„åˆ™ï¼ˆä¸Šæµ·æ•²éº»ï¼‰</h3>
                <ul>
                    <li>èŠ±ç‰ŒåŒ…æ‹¬ï¼šæ˜¥å¤ç§‹å†¬ã€æ¢…å…°ç«¹èŠï¼ˆ8å¼ ï¼‰</li>
                    <li><strong>ä¸­å‘ç™½ä¹Ÿç®—èŠ±ç‰Œï¼</strong>æ‘¸åˆ°è‡ªåŠ¨äº®å‡ºè¡¥ç‰Œ</li>
                    <li>æ‘¸åˆ°èŠ±ç‰Œè‡ªåŠ¨è¡¥èŠ±ï¼Œç›´åˆ°æ‘¸åˆ°æ™®é€šç‰Œä¸ºæ­¢</li>
                    <li>èƒ¡ç‰Œæ—¶æ¯ä¸ªèŠ±ç‰ŒåŠ 1åˆ†</li>
                </ul>
            </div>
            
            <div class="rules-section">
                <h3>ğŸ¯ èƒ¡ç‰Œæ¡ä»¶</h3>
                <ul>
                    <li><strong>åŸºæœ¬å‹ï¼š</strong>4ç»„é¢å­ï¼ˆé¡ºå­æˆ–åˆ»å­ï¼‰+ 1å¯¹å°†</li>
                    <li><strong>ä¸ƒå¯¹å­ï¼š</strong>7å¯¹ä¸åŒçš„å¯¹å­</li>
                    <li><strong>åä¸‰å¹ºï¼š</strong>1ã€9ä¸‡ç­’æ¡ + ä¸œå—è¥¿åŒ—ä¸­å‘ç™½å„ä¸€å¼  + ä»»æ„ä¸€å¼ é…å¯¹</li>
                </ul>
            </div>
            
            <div class="rules-section">
                <h3>ğŸ”” ç‰¹æ®Šæ“ä½œï¼ˆä¸Šæµ·æ•²éº»ï¼‰</h3>
                <ul>
                    <li><strong>âŒ ä¸èƒ½åƒï¼š</strong>ä¸Šæµ·éº»å°†ä¸èƒ½åƒç‰Œï¼</li>
                    <li><strong>ç¢°ï¼š</strong>åˆ«äººæ‰“å‡ºçš„ç‰Œä¸è‡ªå·±æ‰‹ä¸­ä¸¤å¼ ç›¸åŒ</li>
                    <li><strong>æ ï¼š</strong>å››å¼ ç›¸åŒçš„ç‰Œï¼ˆæ˜æ ã€æš—æ ã€åŠ æ ï¼‰</li>
                    <li><strong>èƒ¡ï¼š</strong>å‡‘é½èƒ¡ç‰Œç‰Œå‹å³å¯èƒ¡ç‰Œ</li>
                    <li><strong>æ•²ï¼š</strong>é—¨æ¸…å¬ç‰Œåå¯æ•²ï¼ˆæç¤ºå¬ç‰Œï¼‰</li>
                </ul>
            </div>
            
            <div class="rules-section">
                <h3>ğŸ’° ä¸Šæµ·æ•²éº»ç•ªå‹</h3>
                <ul>
                    <li><strong>é—¨æ¸…ï¼š</strong>+1ç•ªï¼ˆä¸ç¢°ä¸æ èƒ¡ç‰Œï¼‰</li>
                    <li><strong>è‡ªæ‘¸ï¼š</strong>+1ç•ªï¼ˆè‡ªå·±æ‘¸ç‰Œèƒ¡ï¼‰</li>
                    <li><strong>æ··ä¸€è‰²ï¼š</strong>+2ç•ªï¼ˆä¸€ç§èŠ±è‰²+å­—ç‰Œï¼‰</li>
                    <li><strong>ç¢°ç¢°èƒ¡ï¼š</strong>+2ç•ªï¼ˆå…¨éƒ¨åˆ»å­ï¼‰</li>
                    <li><strong>ä¸ƒå¯¹å­ï¼š</strong>+2ç•ªï¼ˆ7å¯¹ç‰Œï¼‰</li>
                    <li><strong>æ¸…ä¸€è‰²ï¼š</strong>+3ç•ªï¼ˆå…¨åŒä¸€èŠ±è‰²ï¼‰</li>
                    <li><strong>æ¸…ç¢°ï¼š</strong>+4ç•ªï¼ˆæ¸…ä¸€è‰²+ç¢°ç¢°èƒ¡ï¼‰</li>
                    <li><strong>æ å¼€ï¼š</strong>+1ç•ªï¼ˆæ åèƒ¡ç‰Œï¼‰</li>
                    <li><strong>æµ·åº•æï¼š</strong>+1ç•ªï¼ˆæœ€åä¸€å¼ ç‰Œèƒ¡ï¼‰</li>
                    <li><strong>å…«èŠ±æŠ¥é“ï¼š</strong>+8ç•ªï¼ˆé›†é½8å¼ èŠ±ç‰Œï¼‰</li>
                </ul>
            </div>
            
            <div class="rules-section">
                <h3>ğŸ’µ è®¡åˆ†è¯´æ˜</h3>
                <ul>
                    <li>åº•åˆ† Ã— 2^ç•ªæ•° = åŸºç¡€å¾—åˆ†</li>
                    <li>æ¯å¼ èŠ±ç‰Œ +1åˆ†</li>
                    <li>è‡ªæ‘¸ï¼šä¸‰å®¶å„ä»˜ä¸€ä»½</li>
                    <li>ç‚¹ç‚®ï¼šæ”¾ç‚®è€…ä»˜ä¸‰ä»½</li>
                </ul>
            </div>
            
            <button class="menu-btn" onclick="hideRules()" style="margin-top: 20px;">
                <i class="fas fa-arrow-left"></i> è¿”å›èœå•
            </button>
        </div>
    </div>

    <!-- æ¸¸æˆç•Œé¢ -->
    <div class="game-container" id="gameContainer">
        <!-- çŠ¶æ€æ  -->
        <div class="status-bar">
            <div class="status-item">
                <div class="status-icon">ğŸ´</div>
                <span>å‰©ä½™: <span id="remainingTiles">92</span>å¼ </span>
            </div>
            <div class="status-item">
                <div class="status-icon">ğŸ†</div>
                <span>åˆ†æ•°: <span id="playerScore">0</span></span>
            </div>
            <div class="status-item">
                <div class="status-icon" id="menqingIcon">ğŸšª</div>
                <span id="menqingStatus">é—¨æ¸…</span>
            </div>
            <div class="status-item">
                <div class="status-icon">ğŸ²</div>
                <span>å±€æ•°: <span id="roundNum">1</span>/4</span>
            </div>
            <button class="back-btn" onclick="backToMenu()">
                <i class="fas fa-home"></i> è¿”å›
            </button>
        </div>

        <!-- éº»å°†æ¡Œé¢ -->
            <div class="mahjong-table">
            <!-- å¯¹æ‰‹åŒºåŸŸ -->
            <div class="opponents-area">
                <div class="opponent" id="opponent1">
                    <div class="player-info">
                        <div class="player-avatar">ğŸ¤–</div>
                        <span class="player-name">AI-ä¸œ</span>
                        <span class="player-wind">ä¸œ</span>
                </div>
                    <div class="opponent-hand" id="opponent1Hand"></div>
                    <div class="melds-area" id="opponent1Melds"></div>
            </div>
                <div class="opponent" id="opponent2">
                    <div class="player-info">
                        <div class="player-avatar">ğŸ¤–</div>
                        <span class="player-name">AI-å—</span>
                        <span class="player-wind">å—</span>
                    </div>
                    <div class="opponent-hand" id="opponent2Hand"></div>
                    <div class="melds-area" id="opponent2Melds"></div>
                </div>
                <div class="opponent" id="opponent3">
                    <div class="player-info">
                        <div class="player-avatar">ğŸ¤–</div>
                        <span class="player-name">AI-åŒ—</span>
                        <span class="player-wind">åŒ—</span>
                    </div>
                    <div class="opponent-hand" id="opponent3Hand"></div>
                    <div class="melds-area" id="opponent3Melds"></div>
        </div>
    </div>

            <!-- ä¸­å¤®åŒºåŸŸ - å„å®¶å‡ºç‰Œ -->
            <div class="center-area">
                <div class="discard-zone top" id="discard1">
                    <div class="zone-label">ä¸œå®¶å‡ºç‰Œ</div>
                    <div class="discards"></div>
                </div>
                <div class="discard-sides">
                    <div class="discard-zone left" id="discard2">
                        <div class="zone-label">å—å®¶</div>
                        <div class="discards"></div>
                    </div>
                    <div class="discard-zone right" id="discard3">
                        <div class="zone-label">åŒ—å®¶</div>
                        <div class="discards"></div>
                    </div>
                </div>
                <div class="discard-zone bottom" id="discard0">
                    <div class="zone-label">æˆ‘çš„å‡ºç‰Œ</div>
                    <div class="discards"></div>
                </div>
            </div>

            <!-- ç©å®¶åŒºåŸŸ -->
            <div class="player-area">
                <div class="player-info">
                    <div class="player-avatar current-turn" id="playerAvatar">ğŸ˜Š</div>
                    <span class="player-name">ç©å®¶</span>
                    <span class="player-wind">è¥¿</span>
                    <span id="turnIndicator" style="margin-left: 10px; color: var(--gold);">è½®åˆ°ä½ äº†ï¼</span>
                    <span id="flowerCount" style="margin-left: 15px; color: #f1c40f;">ğŸŒ¸ èŠ±ç‰Œ: 0</span>
                </div>
                <div class="hand-container" id="playerHand"></div>
                <div class="melds-area" id="playerMelds"></div>
                <!-- èŠ±ç‰Œå±•ç¤ºåŒº -->
                <div class="flowers-display" id="playerFlowers" style="margin-top: 10px; display: flex; gap: 5px; justify-content: center; flex-wrap: wrap;"></div>
            </div>

            <!-- æ“ä½œæŒ‰é’® -->
            <div class="action-panel">
                <button class="action-btn danger" id="discardBtn" onclick="discardSelected()" disabled>
                    <i class="fas fa-hand-point-down"></i> æ‰“ç‰Œ
                </button>
                <button class="action-btn success" id="huBtn" onclick="checkHu()" disabled>
                    <i class="fas fa-trophy"></i> èƒ¡ç‰Œ
                </button>
                <button class="action-btn secondary" onclick="showTips()">
                    <i class="fas fa-lightbulb"></i> æç¤º
                </button>
                <button class="action-btn secondary" id="soundBtn" onclick="toggleSound()">
                    <i class="fas fa-volume-up"></i> å£°éŸ³
                </button>
                <button class="action-btn secondary" onclick="showFullScoreboard()" style="background: linear-gradient(135deg, #f39c12 0%, #d35400 100%);">
                    <i class="fas fa-trophy"></i> ç§¯åˆ†æ¦œ
                </button>
            </div>
        </div>
    </div>

    <!-- æ“ä½œæç¤ºï¼ˆç¢°æ  - ä¸Šæµ·æ•²éº»ä¸èƒ½åƒï¼‰ -->
    <div class="action-hints" id="actionHints" style="display: none;">
        <button class="hint-btn" id="pengBtn" onclick="doAction('peng')" style="display: none;">ç¢°</button>
        <button class="hint-btn" id="gangBtn" onclick="doAction('gang')" style="display: none;">æ </button>
        <button class="hint-btn" id="huBtn2" onclick="doAction('hu')" style="display: none;">èƒ¡</button>
        <button class="hint-btn" id="passBtn" onclick="doAction('pass')">è¿‡</button>
    </div>

    <!-- æ¶ˆæ¯å¼¹çª— -->
    <div class="modal" id="modal">
        <div class="modal-content">
            <h2 class="modal-title" id="modalTitle">ğŸ‰ æ­å–œï¼</h2>
            <p class="modal-message" id="modalMessage">ä½ èµ¢äº†ï¼</p>
            <div id="modalButtons" style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button class="menu-btn" onclick="continueNextRound()" style="background: linear-gradient(135deg, #2ecc71, #27ae60);">
                    <i class="fas fa-play"></i> ç»§ç»­ä¸‹ä¸€å±€
                </button>
                <button class="menu-btn secondary" onclick="closeModalAndBack()">
                    <i class="fas fa-home"></i> è¿”å›èœå•
                </button>
            </div>
            <!-- æ¸¸æˆå¼€å§‹ä¸“ç”¨æŒ‰é’® -->
            <div id="startGameButtons" style="display: none;">
                <button class="menu-btn" onclick="closeModal()" style="background: linear-gradient(135deg, #2ecc71, #27ae60);">
                    <i class="fas fa-play"></i> å¼€å§‹å‡ºç‰Œ
                </button>
            </div>
            <!-- å¬ç‰Œæç¤ºï¼šç‚¹å‡»ä»»æ„å¤„å…³é—­ -->
            <div id="tingButtons" style="display: none;">
                <p style="color: rgba(255,255,255,0.6); font-size: 0.9rem; margin-top: 15px;">
                    <i class="fas fa-hand-pointer"></i> ç‚¹å‡»ä»»æ„ä½ç½®ç»§ç»­
                </p>
            </div>
        </div>
    </div>

    <script>
        // ==================== æ¸¸æˆæ•°æ® ====================
        const SUITS = ['wan', 'tong', 'tiao'];
        const HONORS = ['dong', 'nan', 'xi', 'bei', 'zhong', 'fa', 'bai'];
        const FLOWERS = ['chun', 'xia', 'qiu', 'dong_hua', 'mei', 'lan', 'zhu', 'ju'];
        const SUIT_NAMES = { wan: 'ä¸‡', tong: 'ç­’', tiao: 'æ¡' };
        const HONOR_CHARS = {
            dong: 'ä¸œ', nan: 'å—', xi: 'è¥¿', bei: 'åŒ—',
            zhong: 'ä¸­', fa: 'å‘', bai: 'ç™½'
        };
        const FLOWER_CHARS = {
            chun: 'æ˜¥', xia: 'å¤', qiu: 'ç§‹', dong_hua: 'å†¬',
            mei: 'æ¢…', lan: 'å…°', zhu: 'ç«¹', ju: 'èŠ'
        };
        const FLOWER_SCORE = 1; // æ¯ä¸ªèŠ±ç‰ŒåŠ 1åˆ†
        
        // ç²¾çµå›¾é…ç½®ï¼ˆæ•´é½çš„8åˆ—Ã—6è¡Œç½‘æ ¼ï¼Œ512x512ï¼‰
        const SPRITE_CONFIG = {
            image: 'img/majiang.png',
            cols: 8,
            rows: 6
        };
        
        // éº»å°†ç‰Œåœ¨ç²¾çµå›¾ä¸­çš„ä½ç½® [row, col]
        // å¸ƒå±€ï¼ˆ8åˆ—Ã—6è¡Œï¼Œ512x512åƒç´ ï¼‰ï¼š
        // Row 0: 1ä¸‡ 2ä¸‡ 3ä¸‡ 4ä¸‡ 5ä¸‡ 6ä¸‡ 7ä¸‡ 8ä¸‡
        // Row 1: 1ç­’ 2ç­’ 3ç­’ 4ç­’ 5ç­’ 6ç­’ 7ç­’ 8ç­’
        // Row 2: 1æ¡ 2æ¡ 3æ¡ 4æ¡ 5æ¡ 6æ¡ 7æ¡ 8æ¡
        // Row 3: ä¸œ å— è¥¿ åŒ— ä¸­ å‘ ç™½ [ç©º]
        // Row 4: ç§‹ å…° ç«¹ æ¢… æ˜¥ å¤ å†¬ èŠ
        // Row 5: 9ä¸‡ 9ç­’ 9æ¡ ...
        
        const TILE_SPRITE_MAP = {
            // ç¬¬0è¡Œ: ä¸‡å­ 1-8
            'wan1': [0, 0], 'wan2': [0, 1], 'wan3': [0, 2], 'wan4': [0, 3],
            'wan5': [0, 4], 'wan6': [0, 5], 'wan7': [0, 6], 'wan8': [0, 7],
            
            // ç¬¬1è¡Œ: ç­’å­ 1-8
            'tong1': [1, 0], 'tong2': [1, 1], 'tong3': [1, 2], 'tong4': [1, 3],
            'tong5': [1, 4], 'tong6': [1, 5], 'tong7': [1, 6], 'tong8': [1, 7],
            
            // ç¬¬2è¡Œ: æ¡å­ 1-8
            'tiao1': [2, 0], 'tiao2': [2, 1], 'tiao3': [2, 2], 'tiao4': [2, 3],
            'tiao5': [2, 4], 'tiao6': [2, 5], 'tiao7': [2, 6], 'tiao8': [2, 7],
            
            // ç¬¬3è¡Œ: å­—ç‰Œ ä¸œå—è¥¿åŒ—ä¸­å‘ç™½
            'dong': [3, 0], 'nan': [3, 1], 'xi': [3, 2], 'bei': [3, 3],
            'zhong': [3, 4], 'fa': [3, 5], 'bai': [3, 6],
            
            // ç¬¬4è¡Œ: èŠ±ç‰Œ ç§‹(3) å…°(1) ç«¹(4) æ¢…(2) æ˜¥ å¤ å†¬ ?
            'qiu': [4, 0],      // ç§‹
            'lan': [4, 1],      // å…°
            'zhu': [4, 2],      // ç«¹
            'mei': [4, 3],      // æ¢…
            'chun': [4, 4],     // æ˜¥
            'xia': [4, 5],      // å¤
            'dong_hua': [4, 6], // å†¬
            'ju': [4, 7],       // èŠ
            
            // ç¬¬5è¡Œ: 9ä¸‡ 9ç­’ 9æ¡ + å…¶ä»–
            'wan9': [5, 0],
            'tong9': [5, 1],
            'tiao9': [5, 2]
        };
        
        // ç•ªå‹å®šä¹‰ï¼ˆä¸Šæµ·æ•²éº»ï¼‰
        const FAN_TYPES = {
            menqing: { name: 'é—¨æ¸…', fan: 1, desc: 'ä¸ç¢°ä¸æ èƒ¡ç‰Œ' },
            zimo: { name: 'è‡ªæ‘¸', fan: 1, desc: 'è‡ªå·±æ‘¸ç‰Œèƒ¡' },
            qingyise: { name: 'æ¸…ä¸€è‰²', fan: 3, desc: 'å…¨éƒ¨åŒä¸€èŠ±è‰²' },
            hunyise: { name: 'æ··ä¸€è‰²', fan: 2, desc: 'ä¸€ç§èŠ±è‰²+å­—ç‰Œ' },
            pengpenghu: { name: 'ç¢°ç¢°èƒ¡', fan: 2, desc: 'å…¨éƒ¨åˆ»å­+å°†' },
            qingpeng: { name: 'æ¸…ç¢°', fan: 4, desc: 'æ¸…ä¸€è‰²+ç¢°ç¢°èƒ¡' },
            qidui: { name: 'ä¸ƒå¯¹å­', fan: 2, desc: '7å¯¹ç‰Œ' },
            gangkai: { name: 'æ å¼€', fan: 1, desc: 'æ åæ‘¸ç‰Œèƒ¡' },
            haidilao: { name: 'æµ·åº•æ', fan: 1, desc: 'æœ€åä¸€å¼ ç‰Œèƒ¡' },
            bahuabaodao: { name: 'å…«èŠ±æŠ¥é“', fan: 8, desc: 'é›†é½8å¼ èŠ±ç‰Œ' }
        };

        let gameState = {
            deck: [],
            players: [
                { hand: [], melds: [], discards: [], flowers: [], isAI: false, wind: 'è¥¿' },
                { hand: [], melds: [], discards: [], flowers: [], isAI: true, wind: 'ä¸œ' },
                { hand: [], melds: [], discards: [], flowers: [], isAI: true, wind: 'å—' },
                { hand: [], melds: [], discards: [], flowers: [], isAI: true, wind: 'åŒ—' }
            ],
            currentPlayer: 0,
            lastDiscard: null,
            lastDiscardPlayer: -1,
            canAction: false,
            selectedTile: -1,
            score: 0,
            round: 1,
            difficulty: 'normal',
            isPlayerTurn: true,
            hasDrawn: false,
            gameOver: false,
            isDrawingFlower: false,  // æ˜¯å¦æ­£åœ¨è¡¥èŠ±
            isTing: false,           // æ˜¯å¦å¬ç‰Œ
            tingList: null           // å¬ä»€ä¹ˆç‰Œ
        };

        // ==================== ç‰Œç»„ç”Ÿæˆ ====================
        function createTile(type, value, suit = null) {
            return { type, value, suit, id: Math.random().toString(36).substr(2, 9) };
        }

        function createDeck() {
            const deck = [];
            
            // ä¸‡ç­’æ¡ 1-9 å„4å¼ 
            SUITS.forEach(suit => {
                for (let value = 1; value <= 9; value++) {
                    for (let i = 0; i < 4; i++) {
                        deck.push(createTile('number', value, suit));
                    }
                }
            });
            
            // å­—ç‰Œå„4å¼ ï¼ˆä¸œå—è¥¿åŒ—ä¸­å‘ç™½ï¼‰
            HONORS.forEach(honor => {
                for (let i = 0; i < 4; i++) {
                    deck.push(createTile('honor', honor, null));
                }
            });
            
            // èŠ±ç‰Œå„1å¼ ï¼ˆæ˜¥å¤ç§‹å†¬æ¢…å…°ç«¹èŠï¼‰
            FLOWERS.forEach(flower => {
                deck.push(createTile('flower', flower, null));
            });
            
            return shuffle([...deck]);
        }
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯èŠ±ç‰Œï¼ˆä¸Šæµ·æ•²éº»ï¼šä¸­å‘ç™½ä¹Ÿç®—èŠ±ç‰Œï¼‰
        function isFlowerTile(tile) {
            if (tile.type === 'flower') return true;
            // ä¸­å‘ç™½ä¹Ÿç®—èŠ±ç‰Œ
            if (tile.type === 'honor' && ['zhong', 'fa', 'bai'].includes(tile.value)) {
                return true;
            }
            return false;
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // ==================== ç‰Œé¢æ¸²æŸ“ ====================
        function getTileDisplay(tile) {
            if (tile.type === 'number') {
                return {
                    value: tile.value,
                    suit: SUIT_NAMES[tile.suit],
                    class: tile.suit
                };
            } else if (tile.type === 'flower') {
                return {
                    value: FLOWER_CHARS[tile.value],
                    suit: 'èŠ±',
                    class: 'hua'
                };
            } else {
                return {
                    value: HONOR_CHARS[tile.value],
                    suit: '',
                    class: 'feng'
                };
            }
        }
        
        // ==================== è¯­éŸ³æ’­æŠ¥ ====================
        const NUM_TO_CHINESE = ['', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹'];
        const SUIT_TO_CHINESE = { wan: 'ä¸‡', tong: 'ç­’', tiao: 'æ¡' };
        const HONOR_TO_CHINESE = {
            dong: 'ä¸œé£', nan: 'å—é£', xi: 'è¥¿é£', bei: 'åŒ—é£',
            zhong: 'çº¢ä¸­', fa: 'å‘è´¢', bai: 'ç™½æ¿'
        };
        const FLOWER_TO_CHINESE = {
            chun: 'æ˜¥', xia: 'å¤', qiu: 'ç§‹', dong2: 'å†¬',
            mei: 'æ¢…', lan: 'å…°', zhu: 'ç«¹', ju: 'èŠ'
        };
        
        let speechEnabled = true;
        let speechReady = false;
        let voiceList = [];
        
        // æ€§åˆ«è¯­éŸ³é€‰æ‹©
        let playerGender = 'female';  // ç©å®¶è¯­éŸ³æ€§åˆ«
        const aiGenders = ['male', 'female', 'male'];  // AI 1/2/3 çš„æ€§åˆ«
        
        // é€‰æ‹©æ€§åˆ«
        function selectGender(gender) {
            playerGender = gender;
            document.getElementById('genderFemale').classList.toggle('active', gender === 'female');
            document.getElementById('genderMale').classList.toggle('active', gender === 'male');
            console.log('é€‰æ‹©è¯­éŸ³æ€§åˆ«:', gender);
        }
        
        // ==================== éŸ³é¢‘æ’­æ”¾ç³»ç»Ÿ ====================
        const audioCache = {}; // ç¼“å­˜å·²åŠ è½½çš„éŸ³é¢‘
        let audioUnlocked = false; // ç§»åŠ¨è®¾å¤‡éŸ³é¢‘æ˜¯å¦å·²è§£é”
        
        // éŸ³é¢‘æ ¼å¼é…ç½®ï¼ˆç»Ÿä¸€ä½¿ç”¨mp3ï¼‰
        const AUDIO_FORMATS = {
            female: '.mp3',
            male: '.mp3'
        };
        
        // è·å–ç‰Œçš„éŸ³é¢‘æ–‡ä»¶åï¼ˆä¸å«æ‰©å±•åï¼‰
        function getTileAudioName(tile) {
            if (tile.type === 'number') {
                // æ•°å­—ç‰Œ: wan1, tong2, tiao3 ç­‰
                return `${tile.suit}${tile.value}`;
            } else if (tile.type === 'flower') {
                // èŠ±ç‰Œ: chun, xia, qiu, dong_hua, mei, lan, zhu, ju
                return tile.value;
            } else {
                // å­—ç‰Œ: dong, nan, xi, bei, zhong, fa, bai
                return tile.value;
            }
        }
        
        // è§£é”ç§»åŠ¨è®¾å¤‡éŸ³é¢‘ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’ï¼‰
        function unlockAudio() {
            if (audioUnlocked) return;
            
            try {
                // åˆ›å»ºä¸€ä¸ªé™éŸ³éŸ³é¢‘å¹¶æ’­æ”¾ï¼Œè§£é”éŸ³é¢‘ä¸Šä¸‹æ–‡
                const silentAudio = new Audio('data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+M4wAAAAAAAAAAAAEluZm8AAAAPAAAAAwAAAbAAqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV//////////////////////////////////////////////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAAbD/kaYhAAAAAAD/4xjAAAAANIAAAAAExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/jGMAD/0AAAANIAAAAATVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV');
                silentAudio.play().then(() => {
                    audioUnlocked = true;
                    console.log('ç§»åŠ¨è®¾å¤‡éŸ³é¢‘å·²è§£é”');
                }).catch(e => {});
            } catch (e) {}
        }
        
        // ç›‘å¬ç”¨æˆ·äº¤äº’ä»¥è§£é”éŸ³é¢‘
        ['click', 'touchstart', 'keydown'].forEach(event => {
            document.addEventListener(event, unlockAudio, { once: false, passive: true });
        });
        
        // æ’­æ”¾éŸ³é¢‘æ–‡ä»¶
        function playAudioFile(path, volume = 1.0) {
            if (!speechEnabled) return;
            
            try {
                // æ£€æŸ¥ç¼“å­˜
                if (audioCache[path]) {
                    const audio = audioCache[path].cloneNode();
                    audio.volume = volume;
                    audio.play().catch(e => console.log('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', e));
                    return;
                }
                
                // åŠ è½½å¹¶æ’­æ”¾
                const audio = new Audio(path);
                audio.volume = volume;
                audio.play().then(() => {
                    // æˆåŠŸï¼Œç¼“å­˜éŸ³é¢‘
                    audioCache[path] = audio;
                }).catch(e => {
                    console.log('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', path, e);
                    // å›é€€åˆ°èœ‚é¸£éŸ³
                    playBeep(523, 100);
                });
            } catch (e) {
                console.error('éŸ³é¢‘é”™è¯¯:', e);
                playBeep(523, 100);
            }
        }
        
        // è·å–ç©å®¶æ€§åˆ«ï¼ˆ0=ç©å®¶ï¼Œ1/2/3=AIï¼‰
        function getPlayerGenderByIndex(playerIndex) {
            if (playerIndex === 0) {
                return playerGender;  // ç©å®¶è‡ªå·±çš„æ€§åˆ«
            }
            return aiGenders[playerIndex - 1] || 'female';  // AI æ€§åˆ«
        }
        
        // éŸ³é‡é…ç½®ï¼ˆé™ä½å¥³å£°æ¥å¹³è¡¡ï¼Œå› ä¸º volume æœ€å¤§åªèƒ½æ˜¯ 1.0ï¼‰
        const AUDIO_VOLUMES = {
            female: 0.6,  // é™ä½å¥³å£°éŸ³é‡
            male: 1.0     // ç”·å£°æ»¡éŸ³é‡
        };
        
        // æ’­æ”¾ç‰Œçš„éŸ³é¢‘ï¼ˆæ”¯æŒç”·å¥³å£°ï¼Œæ³¨æ„ï¼šå•äººæ¨¡å¼åœ¨ mahjong/ å­ç›®å½•ï¼‰
        function playTileAudio(tile, gender = 'female') {
            const name = getTileAudioName(tile);
            const format = AUDIO_FORMATS[gender] || '.mp3';
            const volume = AUDIO_VOLUMES[gender] || 1.0;
            playAudioFile(`../audio/${gender}/tiles/${name}${format}`, volume);
        }
        
        // æ’­æ”¾åŠ¨ä½œéŸ³é¢‘ï¼ˆæ”¯æŒç”·å¥³å£°ï¼‰
        function playActionAudio(action, gender = 'female') {
            const format = AUDIO_FORMATS[gender] || '.mp3';
            const volume = AUDIO_VOLUMES[gender] || 1.0;
            playAudioFile(`../audio/${gender}/actions/${action}${format}`, volume);
        }
        
        // é¢„åŠ è½½éŸ³é¢‘ - åªé¢„åŠ è½½é€‰å®šæ€§åˆ«çš„åŠ¨ä½œéŸ³é¢‘ï¼Œé¿å…å¡é¡¿
        function preloadAudio() {
            // åªé¢„åŠ è½½å½“å‰é€‰æ‹©æ€§åˆ«çš„åŠ¨ä½œéŸ³é¢‘ï¼ˆæœ€é‡è¦çš„å‡ ä¸ªï¼‰
            const actions = ['peng', 'gang', 'hu', 'zimo'];
            const format = AUDIO_FORMATS[playerGender] || '.mp3';
            
            actions.forEach(a => {
                const path = `../audio/${playerGender}/actions/${a}${format}`;
                const audio = new Audio(path);
                audio.load();
                audioCache[path] = audio;
            });
            console.log('åŠ¨ä½œéŸ³é¢‘é¢„åŠ è½½å®Œæˆï¼Œå…¶ä»–ä½¿ç”¨æ‡’åŠ è½½');
        }
        
        // ==================== èµ„æºé¢„åŠ è½½ ====================
        let spriteLoaded = false;
        let loadingProgress = 0;
        
        // é¢„åŠ è½½éº»å°†ç‰Œç²¾çµå›¾ï¼ˆå…³é”®èµ„æºï¼‰
        function preloadSprite() {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    spriteLoaded = true;
                    loadingProgress = 100;
                    document.body.classList.add('sprites-loaded');
                    updateLoadingStatus();
                    console.log('éº»å°†ç‰Œè´´å›¾åŠ è½½å®Œæˆ');
                    
                    // åº”ç”¨æ ·å¼åˆ°æ‰€æœ‰åŠ è½½ä¸­çš„ç‰Œ
                    document.querySelectorAll('.tile.loading').forEach(tile => {
                        tile.classList.remove('loading');
                        if (tile.dataset.spriteStyle) {
                            tile.style.cssText = tile.dataset.spriteStyle;
                        }
                    });
                    
                    resolve();
                };
                img.onerror = () => {
                    console.error('éº»å°†ç‰Œè´´å›¾åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æ–‡å­—æ¨¡å¼');
                    spriteLoaded = true;
                    document.body.classList.add('sprites-loaded');
                    updateLoadingStatus();
                    
                    // è½¬æ¢ä¸ºæ–‡å­—æ¨¡å¼
                    document.querySelectorAll('.tile.loading').forEach(tile => {
                        tile.classList.remove('loading');
                        tile.classList.add('text-mode');
                    });
                    
                    resolve();
                };
                // å¼€å§‹åŠ è½½
                loadingProgress = 30;
                updateLoadingStatus();
                img.src = 'img/majiang.png';
            });
        }
        
        // æ›´æ–°åŠ è½½çŠ¶æ€æ˜¾ç¤º
        function updateLoadingStatus() {
            const btns = document.querySelectorAll('.menu-btn.game-start');
            btns.forEach(btn => {
                if (spriteLoaded) {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                } else {
                    btn.disabled = true;
                    btn.style.opacity = '0.6';
                }
            });
            
            const loadingText = document.getElementById('loadingText');
            if (loadingText) {
                if (spriteLoaded) {
                    loadingText.textContent = 'âœ“ èµ„æºåŠ è½½å®Œæˆ';
                    loadingText.style.color = '#2ecc71';
                } else {
                    loadingText.textContent = `åŠ è½½ä¸­... ${loadingProgress}%`;
                }
            }
        }
        
        // é¡µé¢åŠ è½½åé¢„åŠ è½½èµ„æº
        document.addEventListener('DOMContentLoaded', () => {
            // ç«‹å³é¢„åŠ è½½ç²¾çµå›¾ï¼ˆæœ€é‡è¦ï¼‰
            preloadSprite();
            // å»¶è¿Ÿé¢„åŠ è½½éŸ³é¢‘
            setTimeout(preloadAudio, 500);
        });
        
        // ==================== è¯­éŸ³æ’­æŠ¥ï¼ˆå·²ç”¨éŸ³é¢‘æ›¿ä»£ï¼‰ ====================
        
        // è·å–ç‰Œçš„ä¸­æ–‡åç§°ï¼ˆç”¨äºè¯­éŸ³ï¼‰
        function getTileSpeechName(tile) {
            if (tile.type === 'number') {
                return NUM_TO_CHINESE[tile.value] + SUIT_TO_CHINESE[tile.suit];
            } else if (tile.type === 'flower') {
                return FLOWER_TO_CHINESE[tile.value] || tile.value;
            } else {
                return HONOR_TO_CHINESE[tile.value] || tile.value;
            }
        }
        
        // ä¸åŒç©å®¶çš„éŸ³è°ƒé…ç½®
        const PLAYER_VOICE = {
            0: { pitch: 1.2, rate: 0.95, gender: 'female' },  // ç©å®¶ï¼šå¥³å£°
            1: { pitch: 0.8, rate: 0.9, gender: 'male' },     // ä¸œå®¶ï¼šç”·å£°1
            2: { pitch: 0.9, rate: 1.0, gender: 'male' },     // å—å®¶ï¼šç”·å£°2
            3: { pitch: 0.7, rate: 0.85, gender: 'male' }     // åŒ—å®¶ï¼šç”·å£°3
        };
        
        // å¥³å£°è¯­éŸ³å…³é”®è¯
        const FEMALE_VOICE_KEYWORDS = [
            'Xiaoxiao', 'Tingting', 'Meijia', 'Hanhan', 'Xiaoyi', 'Xiaomo',
            'female', 'Female', 'woman', 'Woman', 'å¥³'
        ];
        
        // ç”·å£°è¯­éŸ³å…³é”®è¯
        const MALE_VOICE_KEYWORDS = [
            'Yunxi', 'Yunyang', 'Yunjian', 'Yunze',
            'male', 'Male', 'man', 'Man', 'ç”·'
        ];
        
        // ç¼“å­˜æ‰¾åˆ°çš„ç”·å¥³å£°éŸ³
        let femaleVoice = null;
        let maleVoice = null;
        
        // åˆå§‹åŒ–è¯­éŸ³ç³»ç»Ÿï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’ï¼‰
        function initSpeechSystem() {
            if (speechReady) return;
            
            try {
                // åˆå§‹åŒ– AudioContext
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // å°è¯•åŠ è½½è¯­éŸ³
                if (window.speechSynthesis) {
                    const voices = speechSynthesis.getVoices();
                    if (voices.length > 0) {
                        findVoices(voices);
                    }
                    
                    speechSynthesis.onvoiceschanged = () => {
                        findVoices(speechSynthesis.getVoices());
                    };
                    
                    // æ’­æ”¾ä¸€ä¸ªç©ºçš„æµ‹è¯•
                    const testUtterance = new SpeechSynthesisUtterance('');
                    testUtterance.volume = 0;
                    speechSynthesis.speak(testUtterance);
                }
                
                speechReady = true;
                console.log('è¯­éŸ³ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ');
            } catch (e) {
                console.error('è¯­éŸ³ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', e);
            }
        }
        
        // æŸ¥æ‰¾åˆé€‚çš„è¯­éŸ³
        function findVoices(voices) {
            // æŸ¥æ‰¾ä¸­æ–‡è¯­éŸ³
            const zhVoices = voices.filter(v => v.lang.includes('zh') || v.lang.includes('CN'));
            
            // æŸ¥æ‰¾å¥³å£°
            femaleVoice = zhVoices.find(v => 
                FEMALE_VOICE_KEYWORDS.some(k => v.name.includes(k))
            ) || zhVoices[0];
            
            // æŸ¥æ‰¾ç”·å£°
            maleVoice = zhVoices.find(v => 
                MALE_VOICE_KEYWORDS.some(k => v.name.includes(k))
            ) || zhVoices[0];
            
            console.log('æ‰¾åˆ°è¯­éŸ³:', { female: femaleVoice?.name, male: maleVoice?.name });
        }
        
        // åœ¨ç”¨æˆ·é¦–æ¬¡äº¤äº’æ—¶åˆå§‹åŒ–
        document.addEventListener('click', function initOnClick() {
            initSpeechSystem();
            document.removeEventListener('click', initOnClick);
        }, { once: true });
        
        document.addEventListener('touchstart', function initOnTouch() {
            initSpeechSystem();
            document.removeEventListener('touchstart', initOnTouch);
        }, { once: true });
        
        // æŒ¯åŠ¨å¤‡ç”¨æ–¹æ¡ˆ
        function vibrate(duration = 50) {
            if (navigator.vibrate) {
                navigator.vibrate(duration);
            }
        }
        
        // æ’­æ”¾ç®€å•éŸ³æ•ˆï¼ˆå…¼å®¹æ€§æ›´å¥½ï¼‰
        function playBeep(frequency = 440, duration = 100, type = 'sine') {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') audioContext.resume();
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration / 1000);
            } catch (e) {
                // é™é»˜å¤±è´¥
            }
        }
        
        // è¯­éŸ³æ’­æŠ¥ï¼ˆæ ¹æ®æ€§åˆ«é€‰æ‹©ä¸åŒè¯­éŸ³ï¼‰+ å¤‡ç”¨éŸ³æ•ˆ
        function speak(text, rate = 1.0, pitch = 1.0, gender = 'female') {
            if (!speechEnabled) {
                return;
            }
            
            // å¤‡ç”¨ï¼šæ’­æ”¾æç¤ºéŸ³
            playBeep(gender === 'female' ? 523 : 392, 60);
            
            if (!window.speechSynthesis) {
                vibrate(30);
                return;
            }
            
            try {
                // å–æ¶ˆä¹‹å‰çš„è¯­éŸ³
                window.speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'zh-CN';
                utterance.rate = rate;
                utterance.pitch = pitch;
                utterance.volume = 1.0;
                
                // æ ¹æ®æ€§åˆ«é€‰æ‹©è¯­éŸ³
                if (gender === 'female' && femaleVoice) {
                    utterance.voice = femaleVoice;
                } else if (gender === 'male' && maleVoice) {
                    utterance.voice = maleVoice;
                }
                
                window.speechSynthesis.speak(utterance);
                speechReady = true;
            } catch (e) {
                console.error('è¯­éŸ³æ’­æŠ¥å¤±è´¥:', e);
            }
        }
        
        // ç”¨æŒ‡å®šç©å®¶çš„å£°éŸ³æ’­æŠ¥ï¼ˆå¥³å£°ç»™ç©å®¶ï¼Œç”·å£°ç»™AIï¼‰
        function speakAs(playerIndex, text) {
            const voice = PLAYER_VOICE[playerIndex] || PLAYER_VOICE[0];
            speak(text, voice.rate, voice.pitch, voice.gender);
        }
        
        // æ’­æŠ¥æ‰“å‡ºçš„ç‰Œï¼ˆä½¿ç”¨éŸ³é¢‘æ–‡ä»¶ï¼Œæ”¯æŒç”·å¥³å£°ï¼‰
        function speakDiscard(tile, playerIndex = 0) {
            const tileName = getTileSpeechName(tile);
            const gender = getPlayerGenderByIndex(playerIndex);
            
            // æ˜¾ç¤ºè°å‡ºçš„ç‰Œï¼ˆå¸®åŠ©åŒºåˆ†ï¼‰
            const playerNames = ['ä½ ', 'ä¸œå®¶', 'å—å®¶', 'åŒ—å®¶'];
            if (playerIndex > 0) {
                showToast(`${playerNames[playerIndex]}ï¼š${tileName}`, 800);
            }
            
            // ä½¿ç”¨éŸ³é¢‘æ–‡ä»¶æ’­æ”¾ï¼ˆä¼ å…¥ç©å®¶æ€§åˆ«ï¼‰
            playTileAudio(tile, gender);
        }
        
        // æ’­æŠ¥ç¢°ç‰Œï¼ˆç©å®¶ç¢°ï¼Œç”¨ç©å®¶æ€§åˆ«ï¼‰
        function speakPeng(tile) {
            playActionAudio('peng', playerGender);
        }
        
        // æ’­æŠ¥æ ç‰Œï¼ˆç©å®¶æ ï¼Œç”¨ç©å®¶æ€§åˆ«ï¼‰
        function speakGang(tile) {
            playActionAudio('gang', playerGender);
        }
        
        // æ’­æŠ¥å¬ç‰Œï¼ˆç©å®¶å¬ï¼Œç”¨ç©å®¶æ€§åˆ«ï¼‰
        function speakTing() {
            playActionAudio('ting', playerGender);
        }
        
        // æ’­æŠ¥èƒ¡ç‰Œï¼ˆéœ€è¦ä¼ å…¥èƒ¡ç‰Œè€…ç´¢å¼•ï¼‰
        function speakHu(winnerIndex = 0) {
            const gender = getPlayerGenderByIndex(winnerIndex);
            playActionAudio('hu', gender);
        }
        
        // æ’­æŠ¥æ”¾ç‚®ï¼ˆå¸¦çˆ†ç‚¸éŸ³æ•ˆï¼‰
        function speakFangPao(loserIndex) {
            // å…ˆæ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
            playExplosionSound();
            // ç„¶åè¯­éŸ³
            setTimeout(() => {
                const names = ['ä½ ', 'ä¸œå®¶', 'å—å®¶', 'åŒ—å®¶'];
                speak(`${names[loserIndex]}æ”¾ç‚®`, 0.8, 0.5);
            }, 300);
        }
        
        // å…¨å±€AudioContextï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’åæ‰èƒ½åˆ›å»ºï¼‰
        let audioContext = null;
        
        function getAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('æ— æ³•åˆ›å»ºAudioContext:', e);
                }
            }
            // å¦‚æœè¢«æš‚åœï¼Œæ¢å¤å®ƒ
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            return audioContext;
        }
        
        // ç®€å•çš„çˆ†ç‚¸éŸ³æ•ˆï¼ˆä½¿ç”¨Web Audio APIï¼‰
        function playExplosionSound() {
            const ctx = getAudioContext();
            if (!ctx) {
                // å¤‡ç”¨æ–¹æ¡ˆï¼šç”¨è¯­éŸ³è¯´"ç °"
                speak('ç °', 0.5, 0.3);
                return;
            }
            
            try {
                // åˆ›å»ºå™ªéŸ³
                const bufferSize = ctx.sampleRate * 0.4; // 0.4ç§’
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    // è¡°å‡çš„å™ªéŸ³ + ä½é¢‘éœ‡åŠ¨
                    const decay = Math.pow(1 - i / bufferSize, 1.5);
                    const noise = (Math.random() * 2 - 1) * decay;
                    const lowFreq = Math.sin(i * 0.05) * decay * 0.5;
                    data[i] = noise + lowFreq;
                }
                
                const source = ctx.createBufferSource();
                source.buffer = buffer;
                
                // ä½é€šæ»¤æ³¢å™¨è®©å£°éŸ³æ›´åƒçˆ†ç‚¸
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;
                
                // å¢ç›Šæ§åˆ¶éŸ³é‡
                const gain = ctx.createGain();
                gain.gain.value = 0.8;
                
                source.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                
                source.start();
                console.log('çˆ†ç‚¸éŸ³æ•ˆå·²æ’­æ”¾');
            } catch (e) {
                console.log('çˆ†ç‚¸éŸ³æ•ˆæ’­æ”¾å¤±è´¥:', e);
                // å¤‡ç”¨æ–¹æ¡ˆ
                speak('ç °', 0.5, 0.3);
            }
        }
        
        // åœ¨ç”¨æˆ·ç¬¬ä¸€æ¬¡äº¤äº’æ—¶åˆå§‹åŒ–AudioContext
        document.addEventListener('click', function initAudio() {
            getAudioContext();
            document.removeEventListener('click', initAudio);
        }, { once: true });
        
        // åˆå§‹åŒ–è¯­éŸ³
        function initSpeech() {
            if (!window.speechSynthesis) {
                console.log('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆAPI');
                return;
            }
            
            // åŠ è½½è¯­éŸ³åˆ—è¡¨
            function loadVoices() {
                voiceList = window.speechSynthesis.getVoices();
                
                if (voiceList.length > 0) {
                    // æ‰¾ä¸­æ–‡è¯­éŸ³
                    const chineseVoices = voiceList.filter(v => 
                        v.lang.includes('zh') || v.lang.includes('CN')
                    );
                    
                    // æ‰¾å¥³å£°
                    femaleVoice = chineseVoices.find(v => 
                        FEMALE_VOICE_KEYWORDS.some(k => v.name.includes(k))
                    );
                    
                    // æ‰¾ç”·å£°
                    maleVoice = chineseVoices.find(v => 
                        MALE_VOICE_KEYWORDS.some(k => v.name.includes(k))
                    );
                    
                    // å¦‚æœæ²¡æ‰¾åˆ°ç‰¹å®šæ€§åˆ«ï¼Œç”¨ç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªä¸­æ–‡è¯­éŸ³
                    if (!femaleVoice && chineseVoices.length > 0) {
                        femaleVoice = chineseVoices[0];
                    }
                    if (!maleVoice && chineseVoices.length > 1) {
                        maleVoice = chineseVoices[1];
                    } else if (!maleVoice) {
                        maleVoice = femaleVoice; // å®åœ¨æ²¡æœ‰å°±ç”¨åŒä¸€ä¸ª
                    }
                    
                    console.log('ğŸ¤ å¥³å£°:', femaleVoice?.name || 'æ— ');
                    console.log('ğŸ¤ ç”·å£°:', maleVoice?.name || 'æ— ');
                }
            }
            
            loadVoices();
            
            // æœ‰äº›æµè§ˆå™¨éœ€è¦ç­‰å¾…äº‹ä»¶
            if (window.speechSynthesis.onvoiceschanged !== undefined) {
                window.speechSynthesis.onvoiceschanged = loadVoices;
            }
        }
        
        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–è¯­éŸ³
        initSpeech();
        
        // åˆ‡æ¢å£°éŸ³å¼€å…³ï¼ˆåŒæ—¶æµ‹è¯•è¯­éŸ³ï¼‰
        function toggleSound() {
            // å…ˆå°è¯•æ¿€æ´»è¯­éŸ³ï¼ˆè§£å†³æµè§ˆå™¨è‡ªåŠ¨æ’­æ”¾é™åˆ¶ï¼‰
            if (!speechReady && speechEnabled) {
                // ç¬¬ä¸€æ¬¡ç‚¹å‡»æ—¶æµ‹è¯•è¯­éŸ³
                speak('éº»å°†', 1.0, 1.0);
                showToast('è¯­éŸ³å·²æ¿€æ´»ï¼');
                return;
            }
            
            speechEnabled = !speechEnabled;
            const btn = document.getElementById('soundBtn');
            if (speechEnabled) {
                btn.innerHTML = '<i class="fas fa-volume-up"></i> å£°éŸ³';
                btn.style.opacity = '1';
                speak('å¼€', 1.0, 1.0);
            } else {
                btn.innerHTML = '<i class="fas fa-volume-mute"></i> é™éŸ³';
                btn.style.opacity = '0.6';
                showToast('è¯­éŸ³å·²å…³é—­');
            }
        }
        
        // æµ‹è¯•è¯­éŸ³ï¼ˆè°ƒè¯•ç”¨ï¼‰- æ¼”ç¤ºä¸åŒç©å®¶çš„å£°éŸ³
        function testSpeech() {
            console.log('æµ‹è¯•è¯­éŸ³...');
            console.log('speechSynthesis:', !!window.speechSynthesis);
            console.log('voiceList:', voiceList.length);
            
            // ä¾æ¬¡æ’­æ”¾ä¸åŒç©å®¶çš„å£°éŸ³
            setTimeout(() => speakAs(0, 'ä¸‰ä¸‡'), 0);
            setTimeout(() => speakAs(1, 'äº”ç­’'), 1500);
            setTimeout(() => speakAs(2, 'ä¸ƒæ¡'), 3000);
            setTimeout(() => speakAs(3, 'ä¸œé£'), 4500);
        }

        function renderTile(tile, options = {}) {
            const { small = false, back = false, selectable = false, index = -1, isNew = false } = options;
            const display = getTileDisplay(tile);
            
            let classes = ['tile', display.class];
            if (small) classes.push('small');
            if (back) classes.push('back');
            if (selectable && gameState.selectedTile === index) classes.push('selected');
            if (isNew) classes.push('new-tile');
            
            // ç²¾çµå›¾æœªåŠ è½½å®Œæˆæ—¶æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            if (!spriteLoaded) {
                classes.push('loading');
            }
            
            if (back) {
                return `<div class="${classes.join(' ')}"></div>`;
            }
            
            // è·å–ç²¾çµå›¾ä½ç½®
            const spritePos = getSpritePosition(tile, small);
            const onclick = selectable ? `onclick="selectTile(${index})"` : '';
            
            // ç²¾çµå›¾åŠ è½½å®Œæˆæ‰åº”ç”¨ä½ç½®æ ·å¼
            const styleAttr = spriteLoaded ? spritePos : '';
            const dataStyle = spriteLoaded ? '' : `data-sprite-style="${spritePos}"`;
            
            return `<div class="${classes.join(' ')}" style="${styleAttr}" ${dataStyle} ${onclick} title="${display.value}${display.suit}">
                <div class="tile-text">
                    <span class="tile-value">${display.value}</span>
                    <span class="tile-suit">${display.suit}</span>
                </div>
            </div>`;
        }
        
        // è·å–ç²¾çµå›¾èƒŒæ™¯ä½ç½®ï¼ˆ8åˆ—Ã—6è¡Œç½‘æ ¼ï¼Œ512x512ï¼‰
        // ä½¿ç”¨ç™¾åˆ†æ¯”ç¡®ä¿åœ¨ä»»ä½•å°ºå¯¸ä¸‹éƒ½æ­£ç¡®æ˜¾ç¤º
        function getSpritePosition(tile, small = false) {
            let key;
            
            if (tile.type === 'number') {
                key = `${tile.suit}${tile.value}`;
            } else if (tile.type === 'flower') {
                key = tile.value;
            } else {
                key = tile.value;
            }
            
            const pos = TILE_SPRITE_MAP[key];
            
            if (!pos) {
                // æ²¡æ‰¾åˆ°æ˜ å°„ï¼Œä½¿ç”¨æ–‡å­—æ¨¡å¼
                return '';
            }
            
            // 8åˆ—Ã—6è¡Œç½‘æ ¼
            const cols = 8;
            const rows = 6;
            
            // ä½¿ç”¨ç™¾åˆ†æ¯”å®šä½ï¼Œç¡®ä¿åœ¨ä»»ä½•å°ºå¯¸ä¸‹éƒ½æ­£ç¡®
            // background-size: 800% 600% è¡¨ç¤ºåŸå›¾æ”¾å¤§åˆ°8å€å®½ã€6å€é«˜ï¼ˆæ¯æ ¼å 100%/8, 100%/6ï¼‰
            // background-position: ç™¾åˆ†æ¯”å…¬å¼ = col/(cols-1)*100%, row/(rows-1)*100%
            const posX = pos[1] === 0 ? 0 : (pos[1] / (cols - 1)) * 100;
            const posY = pos[0] === 0 ? 0 : (pos[0] / (rows - 1)) * 100;
            
            return `background-size: ${cols * 100}% ${rows * 100}%; background-position: ${posX}% ${posY}%;`;
        }

        // ==================== æ¸¸æˆåˆå§‹åŒ– ====================
        function startGame(difficulty) {
            // ç”¨æˆ·ç‚¹å‡»å¼€å§‹æ¸¸æˆæ—¶æ¿€æ´»è¯­éŸ³
            if (speechEnabled && !speechReady) {
                speak('å¼€å§‹');
            }
            
            gameState.difficulty = difficulty;
            gameState.deck = createDeck();
            gameState.score = 0;
            gameState.round = 1;
            gameState.gameOver = false;
            gameState.currentPlayer = 0;
            gameState.selectedTile = -1;
            gameState.hasDrawn = false;
            
            // æ¸…ç©ºæ‰€æœ‰ç©å®¶
            gameState.players.forEach(player => {
                player.hand = [];
                player.melds = [];
                player.discards = [];
                player.flowers = [];  // æ¸…ç©ºèŠ±ç‰Œ
            });
            
            // å‘ç‰Œ
            for (let i = 0; i < 13; i++) {
                gameState.players.forEach((player, playerIndex) => {
                    if (gameState.deck.length > 0) {
                        const tile = gameState.deck.pop();
                        player.hand.push(tile);
                    }
                });
            }
            
            // åº„å®¶å¤šæ‘¸ä¸€å¼ 
            if (gameState.deck.length > 0) {
                gameState.players[0].hand.push(gameState.deck.pop());
                gameState.hasDrawn = true;
            }
            
            // å¤„ç†èµ·æ‰‹èŠ±ç‰Œï¼ˆæ‰€æœ‰ç©å®¶ï¼‰
            gameState.players.forEach((player, playerIndex) => {
                processInitialFlowers(playerIndex);
            });
            
            // æ’åºæ‰‹ç‰Œ
            gameState.players.forEach(player => sortTiles(player.hand));
            
            // ç¡®ä¿åº„å®¶çŠ¶æ€æ­£ç¡®ï¼ˆå·²æœ‰14å¼ ç‰Œï¼Œå¯ä»¥ç›´æ¥å‡ºç‰Œï¼‰
            gameState.hasDrawn = true;
            gameState.currentPlayer = 0;
            
            // æ˜¾ç¤ºæ¸¸æˆç•Œé¢
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('rulesContainer').classList.remove('active');
            document.getElementById('gameContainer').style.display = 'block';
            
            updateUI();
            
            // æ˜¾ç¤ºèµ·æ‰‹èŠ±ç‰Œæƒ…å†µ
            const playerFlowerCount = gameState.players[0].flowers.length;
            let startMsg = 'ä½ æ˜¯åº„å®¶ï¼ˆè¥¿å®¶ï¼‰\nä½ æœ‰14å¼ ç‰Œï¼Œè¯·ç‚¹å‡»é€‰æ‹©å‡ºç‰Œ';
            if (playerFlowerCount > 0) {
                startMsg = `ä½ æœ‰${playerFlowerCount}å¼ èŠ±ç‰Œ ğŸŒ¸\nè¯·ç‚¹å‡»é€‰æ‹©å‡ºç‰Œ`;
            }
            showMessage('æ¸¸æˆå¼€å§‹', startMsg, true); // true = æ¸¸æˆå¼€å§‹å¼¹çª—
        }

        function sortTiles(hand) {
            hand.sort((a, b) => {
                // å…ˆæŒ‰ç±»å‹æ’åº
                if (a.type !== b.type) {
                    return a.type === 'number' ? -1 : 1;
                }
                // æ•°å­—ç‰ŒæŒ‰èŠ±è‰²å’Œæ•°å€¼æ’åº
                if (a.type === 'number') {
                    if (a.suit !== b.suit) {
                        return SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit);
                    }
                    return a.value - b.value;
                }
                // å­—ç‰ŒæŒ‰é¡ºåºæ’åº
                return HONORS.indexOf(a.value) - HONORS.indexOf(b.value);
            });
        }

        function sortHand() {
            sortHandSilent();
            showToast('æ‰‹ç‰Œå·²æ•´ç†');
        }
        
        // é™é»˜ç†ç‰Œï¼ˆä¸æ˜¾ç¤ºæç¤ºï¼‰
        function sortHandSilent() {
            sortTiles(gameState.players[0].hand);
            gameState.selectedTile = -1;
        }
        
        // å¤„ç†èµ·æ‰‹èŠ±ç‰Œ
        function processInitialFlowers(playerIndex) {
            const player = gameState.players[playerIndex];
            let hasFlower = true;
            
            while (hasFlower) {
                hasFlower = false;
                for (let i = player.hand.length - 1; i >= 0; i--) {
                    if (isFlowerTile(player.hand[i])) {
                        // ç§»åˆ°èŠ±ç‰ŒåŒº
                        player.flowers.push(player.hand.splice(i, 1)[0]);
                        // è¡¥ä¸€å¼ ç‰Œ
                        if (gameState.deck.length > 0) {
                            player.hand.push(gameState.deck.pop());
                        }
                        hasFlower = true;
                    }
                }
            }
        }
        
        // è¡¥èŠ±ï¼ˆæ‘¸ç‰Œæ—¶é‡åˆ°èŠ±ç‰Œï¼‰
        function drawAndReplaceFlower(playerIndex, callback) {
            const player = gameState.players[playerIndex];
            
            if (gameState.deck.length === 0) {
                if (callback) callback(null);
                return;
            }
            
            const tile = gameState.deck.pop();
            
            if (isFlowerTile(tile)) {
                // è¿˜æ˜¯èŠ±ç‰Œï¼Œç»§ç»­è¡¥
                player.flowers.push(tile);
                const display = getTileDisplay(tile);
                
                if (playerIndex === 0) {
                    showToast(`è¡¥èŠ±ï¼š${display.value} ğŸŒ¸ ç»§ç»­è¡¥ç‰Œ...`);
                }
                
                updateUI();
                
                setTimeout(() => {
                    drawAndReplaceFlower(playerIndex, callback);
                }, 500);
            } else {
                // ä¸æ˜¯èŠ±ç‰Œï¼Œæ­£å¸¸è¿”å›
                if (callback) callback(tile);
            }
        }

        // ==================== UIæ›´æ–° ====================
        function updateUI() {
            // æ›´æ–°å‰©ä½™ç‰Œæ•°
            document.getElementById('remainingTiles').textContent = gameState.deck.length;
            document.getElementById('playerScore').textContent = gameState.score;
            document.getElementById('roundNum').textContent = gameState.round;
            
            // æ¸²æŸ“ç©å®¶æ‰‹ç‰Œ
            const playerHand = document.getElementById('playerHand');
            const handLength = gameState.players[0].hand.length;
            const isLastTileNew = gameState.hasDrawn && handLength > 0;
            
            playerHand.innerHTML = gameState.players[0].hand.map((tile, index) => {
                const isNewTile = isLastTileNew && index === handLength - 1;
                return renderTile(tile, { selectable: true, index, isNew: isNewTile });
            }).join('');
            
            // æ¸²æŸ“ç©å®¶èŠ±ç‰Œ
            const playerFlowers = document.getElementById('playerFlowers');
            const flowerCount = gameState.players[0].flowers.length;
            playerFlowers.innerHTML = gameState.players[0].flowers.map(tile => 
                renderTile(tile, { small: true })
            ).join('');
            
            // æ˜¾ç¤ºèŠ±ç‰Œæ•°é‡ã€æ‰‹ç‰Œæ•°é‡å’Œå¬ç‰ŒçŠ¶æ€
            const handCount = gameState.players[0].hand.length;
            const meldsCount = gameState.players[0].melds.length;
            let statusText = `ğŸƒ æ‰‹ç‰Œ: ${handCount}å¼ `;
            if (meldsCount > 0) {
                statusText += ` (ç¢°${meldsCount}ç»„)`;
            }
            statusText += ` | ğŸŒ¸ èŠ±ç‰Œ: ${flowerCount} (+${flowerCount * FLOWER_SCORE}åˆ†)`;
            if (gameState.isTing && gameState.tingList) {
                const tingNames = gameState.tingList.map(item => {
                    const d = getTileDisplay(item.tile);
                    return `${d.value}${d.suit}Ã—${item.remaining}`;
                }).slice(0, 4).join(' ');
                statusText += ` | ğŸ¯ <span style="color: #ffd700; font-weight: bold;">å¬ç‰Œä¸­ï¼</span> å¬ï¼š${tingNames}`;
            }
            document.getElementById('flowerCount').innerHTML = statusText;
            
            // æ¸²æŸ“å¯¹æ‰‹æ‰‹ç‰Œï¼ˆèƒŒé¢ï¼‰å’ŒèŠ±ç‰Œæ•°é‡
            for (let i = 1; i <= 3; i++) {
                const opponentHand = document.getElementById(`opponent${i}Hand`);
                const aiFlowers = gameState.players[i].flowers.length;
                opponentHand.innerHTML = gameState.players[i].hand.map(tile => 
                    renderTile(tile, { small: true, back: true })
                ).join('');
                
                // æ˜¾ç¤ºAIèŠ±ç‰Œæ•°é‡
                const opponentInfo = document.querySelector(`#opponent${i} .player-info`);
                let flowerSpan = opponentInfo.querySelector('.flower-count');
                if (!flowerSpan) {
                    flowerSpan = document.createElement('span');
                    flowerSpan.className = 'flower-count';
                    flowerSpan.style.cssText = 'margin-left: 10px; color: #f1c40f; font-size: 0.9rem;';
                    opponentInfo.appendChild(flowerSpan);
                }
                flowerSpan.textContent = `ğŸŒ¸${aiFlowers}`;
            }
            
            // æ¸²æŸ“å„å®¶å‡ºç‰ŒåŒºåŸŸ
            for (let i = 0; i < 4; i++) {
                const discardZone = document.getElementById(`discard${i}`);
                if (discardZone) {
                    const discardsDiv = discardZone.querySelector('.discards');
                    discardsDiv.innerHTML = gameState.players[i].discards.map(tile => 
                        renderTile(tile, { small: true })
                    ).join('');
                }
            }
            
            // æ¸²æŸ“ç©å®¶å‰¯éœ²åŒºï¼ˆç¢°/æ ï¼‰
            const playerMelds = document.getElementById('playerMelds');
            playerMelds.innerHTML = gameState.players[0].melds.map(meld => {
                const tilesHtml = meld.tiles.map(tile => renderTile(tile, { small: true })).join('');
                return `<div class="meld-group ${meld.type}">${tilesHtml}</div>`;
            }).join('');
            
            // æ¸²æŸ“AIå‰¯éœ²åŒº
            for (let i = 1; i <= 3; i++) {
                const aiMelds = document.getElementById(`opponent${i}Melds`);
                if (aiMelds) {
                    aiMelds.innerHTML = gameState.players[i].melds.map(meld => {
                        const tilesHtml = meld.tiles.map(tile => renderTile(tile, { small: true })).join('');
                        return `<div class="meld-group ${meld.type}">${tilesHtml}</div>`;
                    }).join('');
                }
            }
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            updateButtons();
            
            // æ›´æ–°å›åˆæŒ‡ç¤º
            updateTurnIndicator();
            
            // æ›´æ–°é—¨æ¸…çŠ¶æ€
            const isMenQing = gameState.players[0].melds.length === 0;
            const menqingStatus = document.getElementById('menqingStatus');
            const menqingIcon = document.getElementById('menqingIcon');
            if (isMenQing) {
                menqingStatus.textContent = 'é—¨æ¸… âœ“';
                menqingStatus.style.color = '#2ecc71';
                menqingIcon.textContent = 'ğŸšª';
            } else {
                menqingStatus.textContent = 'å·²ç¢°æ ';
                menqingStatus.style.color = '#e74c3c';
                menqingIcon.textContent = 'âŒ';
            }
        }

        function updateButtons() {
            const discardBtn = document.getElementById('discardBtn');
            const huBtn = document.getElementById('huBtn');
            
            const isPlayerTurn = gameState.currentPlayer === 0;
            const hasDrawn = gameState.hasDrawn;
            
            discardBtn.disabled = !isPlayerTurn || gameState.selectedTile === -1 || !hasDrawn || gameState.gameOver;
            huBtn.disabled = !isPlayerTurn || !hasDrawn || gameState.gameOver;
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turnIndicator');
            const avatar = document.getElementById('playerAvatar');
            
            if (gameState.currentPlayer === 0) {
                if (gameState.hasDrawn) {
                    indicator.textContent = 'è¯·ç‚¹å‡»é€‰æ‹©ä¸€å¼ ç‰Œæ‰“å‡º';
                    indicator.style.color = '#2ecc71';
                } else {
                    indicator.textContent = 'è‡ªåŠ¨æ‘¸ç‰Œä¸­...';
                    indicator.style.color = '#f1c40f';
                }
                avatar.classList.add('current-turn');
            } else {
                indicator.textContent = `AI-${['ä¸œ','å—','åŒ—'][gameState.currentPlayer-1]}å‡ºç‰Œä¸­...`;
                indicator.style.color = 'rgba(255,255,255,0.6)';
                avatar.classList.remove('current-turn');
            }
        }

        // ==================== æ¸¸æˆæ“ä½œ ====================
        function selectTile(index) {
            if (gameState.currentPlayer !== 0 || !gameState.hasDrawn) return;
            
            if (gameState.selectedTile === index) {
                // åŒå‡»ç›´æ¥æ‰“å‡º
                discardSelected();
            } else {
                gameState.selectedTile = index;
                updateUI();
            }
        }

        // è‡ªåŠ¨æ‘¸ç‰Œï¼ˆè½®åˆ°ç©å®¶æ—¶è‡ªåŠ¨æ‰§è¡Œï¼‰
        function autoDrawTile() {
            if (gameState.currentPlayer !== 0 || gameState.gameOver) return;
            
            // å¦‚æœå·²ç»æ‘¸è¿‡ç‰Œï¼ˆæ‰‹ç‰Œ14å¼ ï¼‰ï¼Œç›´æ¥è¿”å›
            if (gameState.hasDrawn || gameState.players[0].hand.length >= 14) {
                gameState.hasDrawn = true;
                updateUI();
                return;
            }
            
            if (gameState.deck.length === 0) {
                endGame('æµå±€', 'ç‰Œå·²æ‘¸å®Œï¼Œæœ¬å±€æµå±€');
                return;
            }
            
            const tile = gameState.deck.pop();
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯èŠ±ç‰Œ
            if (isFlowerTile(tile)) {
                gameState.players[0].flowers.push(tile);
                const display = getTileDisplay(tile);
                showToast(`æ‘¸åˆ°èŠ±ç‰Œï¼š${display.value} ğŸŒ¸`);
                
                // æ’­æ”¾èŠ±ç‰ŒéŸ³é¢‘ + è¡¥èŠ±éŸ³é¢‘ï¼ˆç©å®¶æ€§åˆ«ï¼‰
                playTileAudio(tile, playerGender);
                setTimeout(() => playActionAudio('buhua', playerGender), 400);
                
                // ç›´æ¥è¡¥èŠ±ï¼ˆä¸ç”¨setTimeoutï¼Œæ›´å¿«ï¼‰
                autoDrawFlowerReplace();
            } else {
                gameState.players[0].hand.push(tile);
                gameState.hasDrawn = true;
                updateUI();
                const display = getTileDisplay(tile);
                showToast(`æ‘¸åˆ°: ${display.value}${display.suit}`);
            }
        }
        
        // è¡¥èŠ±ï¼ˆç®€åŒ–ç‰ˆï¼Œæ›´å¯é ï¼‰
        function autoDrawFlowerReplace() {
            if (gameState.deck.length === 0) {
                gameState.hasDrawn = true;
                updateUI();
                showToast('ç‰Œå·²æ‘¸å®Œ');
                return;
            }
            
            const tile = gameState.deck.pop();
            
            if (isFlowerTile(tile)) {
                // è¿˜æ˜¯èŠ±ç‰Œï¼Œç»§ç»­è¡¥
                gameState.players[0].flowers.push(tile);
                const display = getTileDisplay(tile);
                showToast(`åˆæ‘¸åˆ°èŠ±ç‰Œï¼š${display.value} ğŸŒ¸`);
                
                // æ’­æ”¾èŠ±ç‰ŒéŸ³é¢‘ + è¡¥èŠ±éŸ³é¢‘ï¼ˆç©å®¶æ€§åˆ«ï¼‰
                playTileAudio(tile, playerGender);
                setTimeout(() => playActionAudio('buhua', playerGender), 400);
                
                updateUI();
                
                // ç»§ç»­è¡¥èŠ±
                setTimeout(() => autoDrawFlowerReplace(), 600);
            } else {
                // ç»ˆäºæ‘¸åˆ°æ™®é€šç‰Œ
                gameState.players[0].hand.push(tile);
                gameState.hasDrawn = true;
                updateUI();
                const display = getTileDisplay(tile);
                showToast(`æ‘¸åˆ°: ${display.value}${display.suit}`);
            }
        }
        
        // æ‰‹åŠ¨æ‘¸ç‰Œï¼ˆå¤‡ç”¨ï¼‰
        function drawTile() {
            autoDrawTile();
        }

        function discardSelected() {
            if (gameState.selectedTile === -1 || gameState.currentPlayer !== 0) return;
            
            // å¦‚æœå·²ç»å¬ç‰Œï¼Œä¸èƒ½é€‰å…¶ä»–ç‰Œæ‰“ï¼ˆåªèƒ½æ‰“åˆšæ‘¸çš„ç‰Œï¼‰
            if (gameState.isTing) {
                const lastIndex = gameState.players[0].hand.length - 1;
                if (gameState.selectedTile !== lastIndex) {
                    showToast('å·²å¬ç‰Œï¼Œåªèƒ½æ‰“åˆšæ‘¸çš„ç‰Œï¼');
                    return;
                }
            }
            
            const tile = gameState.players[0].hand.splice(gameState.selectedTile, 1)[0];
            gameState.players[0].discards.push(tile);
            gameState.lastDiscard = tile;
            gameState.lastDiscardPlayer = 0;
            gameState.selectedTile = -1;
            gameState.hasDrawn = false;
            
            // è¯­éŸ³æ’­æŠ¥æ‰“å‡ºçš„ç‰Œï¼ˆç©å®¶éŸ³è°ƒï¼‰
            speakDiscard(tile, 0);
            
            // è‡ªåŠ¨ç†ç‰Œ
            sortHandSilent();
            
            updateUI();
            
            // æ‰“ç‰Œåæ£€æµ‹å¬ç‰Œï¼ˆ13å¼ ç‰Œæ—¶ï¼‰
            if (!gameState.isTing) {
                checkAndShowTing();
            }
            
            // ä¸‹ä¸€ä¸ªç©å®¶
            nextPlayer();
        }

        function nextPlayer() {
            if (gameState.gameOver) return;
            
            // å¦‚æœæœ‰äººåˆšæ‰“å‡ºç‰Œï¼Œå…ˆæ£€æŸ¥ç©å®¶æ˜¯å¦å¯ä»¥ç¢°/æ /èƒ¡
            if (gameState.lastDiscard && gameState.lastDiscardPlayer !== 0) {
                // AIæ‰“å‡ºçš„ç‰Œï¼Œæ£€æŸ¥ç©å®¶æ˜¯å¦å¯ä»¥æ“ä½œ
                if (showActionHints()) {
                    // æœ‰å¯æ“ä½œçš„ï¼Œç­‰å¾…ç©å®¶é€‰æ‹©
                    console.log('ç­‰å¾…ç©å®¶é€‰æ‹©ç¢°/æ /èƒ¡/è¿‡');
                    return;
                }
            }
            
            // æ²¡æœ‰å¯æ“ä½œçš„ï¼Œç»§ç»­æ­£å¸¸æµç¨‹
            gameState.currentPlayer = (gameState.currentPlayer + 1) % 4;
            gameState.hasDrawn = false;
            
            console.log('nextPlayer: è½®åˆ°ç©å®¶', gameState.currentPlayer);
            
            if (gameState.currentPlayer === 0) {
                // è½®åˆ°ç©å®¶ï¼Œè‡ªåŠ¨æ‘¸ç‰Œ
                playerAutoDrawTile();
            } else {
                // AIå›åˆ
                setTimeout(() => aiTurn(), 600);
            }
        }
        
        // ç©å®¶è‡ªåŠ¨æ‘¸ç‰Œï¼ˆç‹¬ç«‹å‡½æ•°ï¼Œæ›´å¯é ï¼‰
        function playerAutoDrawTile() {
            if (gameState.gameOver) return;
            
            updateUI();
            
            if (gameState.deck.length === 0) {
                endGame('æµå±€', 'ç‰Œå·²æ‘¸å®Œï¼Œæœ¬å±€æµå±€');
                return;
            }
            
            // å»¶è¿Ÿæ‘¸ç‰Œï¼Œè®©UIå…ˆæ›´æ–°
            setTimeout(() => {
                if (gameState.gameOver) return;
                
                const tile = gameState.deck.pop();
                console.log('ç©å®¶æ‘¸ç‰Œ:', tile);
                
                if (isFlowerTile(tile)) {
                    // èŠ±ç‰Œæˆ–ä¸­å‘ç™½ï¼Œæ”¾å…¥èŠ±ç‰ŒåŒº
                    gameState.players[0].flowers.push(tile);
                    const display = getTileDisplay(tile);
                    showToast(`æ‘¸åˆ°${display.value} ğŸŒ¸ è¡¥ç‰Œä¸­...`);
                    
                    // æ’­æ”¾èŠ±ç‰ŒéŸ³é¢‘ + è¡¥èŠ±éŸ³é¢‘ï¼ˆç©å®¶æ€§åˆ«ï¼‰
                    playTileAudio(tile, playerGender);
                    setTimeout(() => playActionAudio('buhua', playerGender), 400);
                    
                    updateUI();
                    
                    // ç»§ç»­æ‘¸ç‰Œç›´åˆ°éèŠ±ç‰Œ
                    setTimeout(() => playerAutoDrawTile(), 700);
            } else {
                // æ™®é€šç‰Œï¼ŒåŠ å…¥æ‰‹ç‰Œï¼ˆæ”¾åœ¨æœ€å³è¾¹ï¼Œä¸ç†ç‰Œï¼‰
                gameState.players[0].hand.push(tile);
                gameState.hasDrawn = true;
                
                // ä¸è‡ªåŠ¨ç†ç‰Œï¼Œè®©æ‘¸åˆ°çš„ç‰Œæ˜¾ç¤ºåœ¨æœ€å³è¾¹
                updateUI();
                
                const display = getTileDisplay(tile);
                showToast(`æ‘¸åˆ°: ${display.value}${display.suit}`);
                    
                    // æ£€æŸ¥æ˜¯å¦èƒ½è‡ªæ‘¸èƒ¡ç‰Œ
                    if (canHu(gameState.players[0].hand)) {
                        showMessage('ğŸŠ è‡ªæ‘¸ï¼', 'ä½ å¯ä»¥èƒ¡ç‰Œäº†ï¼ç‚¹å‡»"èƒ¡ç‰Œ"æŒ‰é’®', 'tip');
                return;
            }
            
                    // å¦‚æœå·²ç»å¬ç‰Œï¼Œè‡ªåŠ¨æ‰“å‡ºåˆšæ‘¸çš„ç‰Œ
                    if (gameState.isTing) {
                        setTimeout(() => {
                            autoDiscardDrawnTile(tile);
                        }, 800);
                    }
                }
            }, 300);
        }
        
        // å¬ç‰Œåè‡ªåŠ¨æ‰“å‡ºæ‘¸åˆ°çš„ç‰Œ
        function autoDiscardDrawnTile(tile) {
            const player = gameState.players[0];
            
            // ä»æ‰‹ç‰Œä¸­ç§»é™¤åˆšæ‘¸çš„ç‰Œï¼ˆæœ€åä¸€å¼ ï¼‰
            const lastIndex = player.hand.length - 1;
            const discardTile = player.hand.splice(lastIndex, 1)[0];
            
            player.discards.push(discardTile);
            gameState.lastDiscard = discardTile;
            gameState.lastDiscardPlayer = 0;
            gameState.hasDrawn = false;
            
            // è¯­éŸ³æ’­æŠ¥æ‰“å‡ºçš„ç‰Œ
            speakDiscard(discardTile, 0);
            
            const display = getTileDisplay(discardTile);
            showToast(`å¬ç‰Œä¸­ï¼Œè‡ªåŠ¨æ‰“å‡º: ${display.value}${display.suit}`);
            
            updateUI();
            nextPlayer();
        }

        // ==================== ç¢°ç‰Œæ£€æµ‹ ====================
        
        // æ£€æŸ¥ç©å®¶æ˜¯å¦å¯ä»¥ç¢°åˆšæ‰“å‡ºçš„ç‰Œ
        function checkPlayerCanPeng() {
            if (!gameState.lastDiscard || gameState.lastDiscardPlayer === 0) {
                return false;
            }
            
            const playerHand = gameState.players[0].hand;
            const discardKey = tileKey(gameState.lastDiscard);
            
            // æ•°æœ‰å‡ å¼ ç›¸åŒçš„ç‰Œ
            let count = 0;
            playerHand.forEach(tile => {
                if (tileKey(tile) === discardKey) count++;
            });
            
            return count >= 2; // æœ‰2å¼ ä»¥ä¸Šå¯ä»¥ç¢°
        }
        
        // æ£€æŸ¥ç©å®¶æ˜¯å¦å¯ä»¥æ åˆšæ‰“å‡ºçš„ç‰Œ
        function checkPlayerCanGang() {
            if (!gameState.lastDiscard || gameState.lastDiscardPlayer === 0) {
                return false;
            }
            
            const playerHand = gameState.players[0].hand;
            const discardKey = tileKey(gameState.lastDiscard);
            
            let count = 0;
            playerHand.forEach(tile => {
                if (tileKey(tile) === discardKey) count++;
            });
            
            return count >= 3; // æœ‰3å¼ å¯ä»¥æ 
        }
        
        // æ£€æŸ¥ç©å®¶æ˜¯å¦å¯ä»¥èƒ¡è¿™å¼ ç‰Œï¼ˆç‚¹ç‚®ï¼‰
        function checkPlayerCanHu() {
            if (!gameState.lastDiscard || gameState.lastDiscardPlayer === 0) {
                return false;
            }
            
            const testHand = [...gameState.players[0].hand, gameState.lastDiscard];
            return canHu(testHand);
        }
        
        // æ˜¾ç¤ºç¢°ç‰Œæ“ä½œæç¤º
        function showActionHints() {
            // å¬ç‰Œååªèƒ½èƒ¡ï¼Œä¸èƒ½ç¢°æ 
            const canPeng = gameState.isTing ? false : checkPlayerCanPeng();
            const canGang = gameState.isTing ? false : checkPlayerCanGang();
            const canHuNow = checkPlayerCanHu();
            
            if (!canPeng && !canGang && !canHuNow) {
                return false; // æ²¡æœ‰å¯æ“ä½œçš„
            }
            
            const actionHints = document.getElementById('actionHints');
            const pengBtn = document.getElementById('pengBtn');
            const gangBtn = document.getElementById('gangBtn');
            const huBtn2 = document.getElementById('huBtn2');
            const passBtn = document.getElementById('passBtn');
            
            pengBtn.style.display = canPeng ? 'inline-block' : 'none';
            gangBtn.style.display = canGang ? 'inline-block' : 'none';
            huBtn2.style.display = canHuNow ? 'inline-block' : 'none';
            passBtn.style.display = 'inline-block';
            
            actionHints.style.display = 'flex';
            
            // æ˜¾ç¤ºè¢«æ‰“å‡ºçš„ç‰Œ
            const display = getTileDisplay(gameState.lastDiscard);
            showToast(`${['ç©å®¶','AI-ä¸œ','AI-å—','AI-åŒ—'][gameState.lastDiscardPlayer]}æ‰“å‡º ${display.value}${display.suit}`);
            
            return true;
        }
        
        // æ‰§è¡Œç¢°ç‰Œ
        function doPeng() {
            const player = gameState.players[0];
            const discardTile = gameState.lastDiscard;
            const discardKey = tileKey(discardTile);
            
            // ä»æ‰‹ç‰Œä¸­ç§»é™¤2å¼ ç›¸åŒçš„ç‰Œ
            let removed = 0;
            player.hand = player.hand.filter(tile => {
                if (removed < 2 && tileKey(tile) === discardKey) {
                    removed++;
                    return false;
                }
                return true;
            });
            
            // æ·»åŠ åˆ°å‰¯éœ²åŒºï¼ˆæ˜åˆ»ï¼‰
            player.melds.push({
                type: 'peng',
                tiles: [discardTile, discardTile, discardTile],
                from: gameState.lastDiscardPlayer
            });
            
            // ä»å‡ºç‰Œç©å®¶çš„å¼ƒç‰Œå †ç§»é™¤ï¼ˆå› ä¸ºè¢«ç¢°äº†ï¼‰
            const discardPlayer = gameState.players[gameState.lastDiscardPlayer];
            discardPlayer.discards.pop();
            
            gameState.lastDiscard = null;
            gameState.currentPlayer = 0;
            gameState.hasDrawn = true; // ç¢°ç‰Œåç›´æ¥å‡ºç‰Œï¼Œä¸ç”¨æ‘¸ç‰Œ
            
            // è¯­éŸ³æ’­æŠ¥ç¢°ç‰Œ
            speakPeng(discardTile);
            
            const display = getTileDisplay(discardTile);
            showToast(`ç¢°ï¼${display.value}${display.suit}`);
            
            updateUI();
        }
        
        // æ‰§è¡Œæ ç‰Œï¼ˆæ˜æ ï¼‰
        function doGang() {
            const player = gameState.players[0];
            const discardTile = gameState.lastDiscard;
            const discardKey = tileKey(discardTile);
            
            // ä»æ‰‹ç‰Œä¸­ç§»é™¤3å¼ ç›¸åŒçš„ç‰Œ
            let removed = 0;
            player.hand = player.hand.filter(tile => {
                if (removed < 3 && tileKey(tile) === discardKey) {
                    removed++;
                    return false;
                }
                return true;
            });
            
            // æ·»åŠ åˆ°å‰¯éœ²åŒºï¼ˆæ˜æ ï¼‰
            player.melds.push({
                type: 'gang',
                tiles: [discardTile, discardTile, discardTile, discardTile],
                from: gameState.lastDiscardPlayer
            });
            
            // ä»å‡ºç‰Œç©å®¶çš„å¼ƒç‰Œå †ç§»é™¤
            const discardPlayer = gameState.players[gameState.lastDiscardPlayer];
            discardPlayer.discards.pop();
            
            gameState.lastDiscard = null;
            gameState.currentPlayer = 0;
            
            // è¯­éŸ³æ’­æŠ¥æ ç‰Œ
            speakGang(discardTile);
            
            const display = getTileDisplay(discardTile);
            showToast(`æ ï¼${display.value}${display.suit} è¡¥ç‰Œä¸­...`);
            
            updateUI();
            
            // æ åè¦è¡¥ä¸€å¼ ç‰Œ
            setTimeout(() => playerAutoDrawTile(), 500);
        }
        
        // ç‚¹ç‚®èƒ¡ç‰Œ
        function doDianPaoHu() {
            const discardTile = gameState.lastDiscard;
            const testHand = [...gameState.players[0].hand, discardTile];
            
            if (canHu(testHand)) {
                const flowerCount = gameState.players[0].flowers.length;
                const flowerBonus = flowerCount * FLOWER_SCORE;
                const fromPlayer = ['ç©å®¶','AI-ä¸œ','AI-å—','AI-åŒ—'][gameState.lastDiscardPlayer];
                
                // æ”¾ç‚®çˆ†ç‚¸éŸ³æ•ˆï¼
                speakFangPao(gameState.lastDiscardPlayer);
                
                endGame('ğŸŠ èƒ¡ç‰Œï¼', `${fromPlayer}ç‚¹ç‚®ï¼ğŸ’¥\nèŠ±ç‰Œ: ${flowerCount}ä¸ª (+${flowerBonus}åˆ†)`);
            }
        }
        
        // ==================== å¬ç‰Œæ£€æµ‹ ====================
        
        // æ£€æŸ¥æ˜¯å¦å¬ç‰Œï¼ˆåªå·®ä¸€å¼ å°±èƒ½èƒ¡ï¼‰
        function checkTingPai(hand, playerIndex = 0) {
            // è€ƒè™‘å‰¯éœ²ï¼šæ‰‹ç‰Œæ•° = 13 - å‰¯éœ²æ•°*3 æˆ–æ›´å°‘
            const player = gameState.players[playerIndex];
            const meldsCount = player ? player.melds.length : 0;
            const expectedSize = 13 - meldsCount * 3; // ç­‰å¾…æ‘¸ç‰Œçš„æ‰‹ç‰Œæ•°
            
            // å…è®¸çš„æ‰‹ç‰Œæ•°é‡ï¼šç­‰å¾…æ‘¸ç‰ŒçŠ¶æ€
            // 0ç¢°: 13å¼ , 1ç¢°: 10å¼ , 2ç¢°: 7å¼ , 3ç¢°: 4å¼ , 4ç¢°: 1å¼ 
            if (hand.length !== expectedSize) return null;
            
            const tingList = [];
            
            // å°è¯•æ·»åŠ æ¯ç§å¯èƒ½çš„ç‰Œï¼Œçœ‹æ˜¯å¦èƒ½èƒ¡
            const allPossibleTiles = getAllPossibleTiles();
            
            for (const tile of allPossibleTiles) {
                const testHand = [...hand, tile];
                if (canHu(testHand, playerIndex)) {
                    // è®¡ç®—è¿™å¼ ç‰Œè¿˜å‰©å¤šå°‘
                    const remaining = countRemainingTiles(tile);
                    tingList.push({ tile, remaining });
                }
            }
            
            return tingList.length > 0 ? tingList : null;
        }
        
        // è®¡ç®—æŸå¼ ç‰Œè¿˜å‰©å¤šå°‘å¼ 
        function countRemainingTiles(targetTile) {
            const targetKey = tileKey(targetTile);
            let total = 4; // æ¯ç§ç‰Œæœ€å¤š4å¼ 
            
            // å‡å»è‡ªå·±æ‰‹ç‰Œä¸­çš„
            gameState.players[0].hand.forEach(t => {
                if (tileKey(t) === targetKey) total--;
            });
            
            // å‡å»è‡ªå·±å‰¯éœ²ä¸­çš„
            gameState.players[0].melds.forEach(meld => {
                meld.tiles.forEach(t => {
                    if (tileKey(t) === targetKey) total--;
                });
            });
            
            // å‡å»æ‰€æœ‰ç©å®¶çš„å¼ƒç‰Œ
            gameState.players.forEach(player => {
                player.discards.forEach(t => {
                    if (tileKey(t) === targetKey) total--;
                });
            });
            
            // å‡å»æ‰€æœ‰ç©å®¶çš„èŠ±ç‰ŒåŒºï¼ˆå¦‚æœæ˜¯èŠ±ç‰Œ/ä¸­å‘ç™½çš„è¯ï¼‰
            gameState.players.forEach(player => {
                player.flowers.forEach(t => {
                    if (tileKey(t) === targetKey) total--;
                });
            });
            
            // å‡å»å…¶ä»–ç©å®¶çš„å‰¯éœ²
            for (let i = 1; i < 4; i++) {
                gameState.players[i].melds.forEach(meld => {
                    meld.tiles.forEach(t => {
                        if (tileKey(t) === targetKey) total--;
                    });
                });
            }
            
            return Math.max(0, total);
        }
        
        // è·å–æ‰€æœ‰å¯èƒ½çš„ç‰Œï¼ˆç”¨äºå¬ç‰Œæ£€æµ‹ï¼‰
        function getAllPossibleTiles() {
            const tiles = [];
            
            // ä¸‡ç­’æ¡ 1-9
            SUITS.forEach(suit => {
                for (let value = 1; value <= 9; value++) {
                    tiles.push({ type: 'number', value, suit });
                }
            });
            
            // å­—ç‰Œï¼ˆä¸œå—è¥¿åŒ—ï¼Œä¸­å‘ç™½å·²ç»æ˜¯èŠ±ç‰Œäº†ï¼‰
            ['dong', 'nan', 'xi', 'bei'].forEach(honor => {
                tiles.push({ type: 'honor', value: honor });
            });
            
            return tiles;
        }
        
        // æ£€æŸ¥å½“å‰æ˜¯å¦å¬ç‰Œå¹¶æ˜¾ç¤ºæç¤º
        function checkAndShowTing() {
            const hand = gameState.players[0].hand;
            const meldsCount = gameState.players[0].melds.length;
            const expectedSize = 13 - meldsCount * 3; // å‡ºç‰Œåçš„æ‰‹ç‰Œæ•°
            
            // å‡ºç‰Œåæ£€æŸ¥å¬ç‰Œ
            // 0ç¢°: 13å¼ , 1ç¢°: 10å¼ , 2ç¢°: 7å¼ , 3ç¢°: 4å¼ 
            if (hand.length === expectedSize) {
                const tingList = checkTingPai(hand, 0);
                
                if (tingList && tingList.length > 0) {
                    gameState.isTing = true;
                    gameState.tingList = tingList;
                    
                    // è¯­éŸ³æ’­æŠ¥"å¬"
                    speakTing();
                    
                    // æ˜¾ç¤ºå¬ç‰Œæç¤ºï¼ˆåŒ…å«å‰©ä½™å¼ æ•°ï¼‰
                    const tingNames = tingList.map(item => {
                        const display = getTileDisplay(item.tile);
                        return `${display.value}${display.suit}(å‰©${item.remaining}å¼ )`;
                    }).join('ã€');
                    
                    // ä½¿ç”¨ 'ting' ç±»å‹ï¼Œç‚¹å‡»ä»»æ„ä½ç½®å…³é—­
                    showMessage('ğŸ¯ å¬ç‰Œäº†ï¼', `ä½ å¬ï¼š${tingNames}\n\nå¬ç‰Œåæ‘¸ä»€ä¹ˆæ‰“ä»€ä¹ˆï¼Œä¸èƒ½æ¢ç‰Œï¼`, 'ting');
                    showToast('å¬ç‰Œäº†ï¼å¬ï¼š' + tingNames);
            } else {
                    gameState.isTing = false;
                    gameState.tingList = null;
                }
            }
        }
        
        // æ£€æŸ¥æ‘¸åˆ°çš„ç‰Œæ˜¯å¦èƒ½èƒ¡
        function checkDrawnTileForHu(tile) {
            const hand = [...gameState.players[0].hand];
            // æœ€åä¸€å¼ æ˜¯åˆšæ‘¸çš„ç‰Œ
            if (canHu(hand)) {
                return true;
            }
            return false;
        }

        function checkAnGang() {
            // æ£€æŸ¥æš—æ 
            const hand = gameState.players[0].hand;
            const counts = {};
            
            hand.forEach(tile => {
                const key = tileKey(tile);
                counts[key] = (counts[key] || 0) + 1;
            });
            
            for (const key in counts) {
                if (counts[key] === 4) {
                    // æœ‰æš—æ æœºä¼šï¼Œè¿™é‡Œå¯ä»¥æ·»åŠ æç¤º
                    break;
                }
            }
        }

        function tileKey(tile) {
            if (tile.type === 'number') {
                return `${tile.suit}${tile.value}`;
            }
            return tile.value;
        }

        // ==================== AIé€»è¾‘ ====================
        function aiTurn() {
            if (gameState.gameOver) return;
            
            const currentAI = gameState.currentPlayer;
            const player = gameState.players[currentAI];
            
            // æ‘¸ç‰Œ
            if (gameState.deck.length === 0) {
                endGame('æµå±€', 'ç‰Œå·²æ‘¸å®Œï¼Œæœ¬å±€æµå±€');
                return;
            }
            
            const tile = gameState.deck.pop();
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯èŠ±ç‰Œï¼ˆåŒ…æ‹¬ä¸­å‘ç™½ï¼‰
            if (isFlowerTile(tile)) {
                player.flowers.push(tile);
                updateUI();
                
                // AIç»§ç»­æ‘¸ç‰Œç›´åˆ°éèŠ±ç‰Œ
                setTimeout(() => aiTurn(), 400);
                return;
            }
            
            player.hand.push(tile);
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥èƒ¡ç‰Œ
            if (canHu(player.hand)) {
                const aiFlowers = player.flowers.length;
                const flowerBonus = aiFlowers * FLOWER_SCORE;
                setTimeout(() => {
                    endGame('AIèƒ¡ç‰Œ', `AI-${['ä¸œ','å—','åŒ—'][currentAI-1]}èƒ¡ç‰Œäº†ï¼\nèŠ±ç‰Œ: ${aiFlowers}ä¸ª (+${flowerBonus}åˆ†)`);
                }, 500);
                return;
            }
            
            // é€‰æ‹©æ‰“å‡ºçš„ç‰Œ
            const discardIndex = aiSelectDiscard(player);
            const discardTile = player.hand.splice(discardIndex, 1)[0];
            player.discards.push(discardTile);
            gameState.lastDiscard = discardTile;
            gameState.lastDiscardPlayer = currentAI;
            
            // è¯­éŸ³æ’­æŠ¥AIæ‰“å‡ºçš„ç‰Œï¼ˆç”¨ä¸åŒéŸ³è°ƒåŒºåˆ†ï¼‰
            speakDiscard(discardTile, currentAI);
            
            updateUI();
            
            // ä¸‹ä¸€ä¸ªç©å®¶
            nextPlayer();
        }
        

        function aiSelectDiscard(player) {
            const hand = player.hand;
            
            // AIç­–ç•¥ï¼š
            // 1. ä¼˜å…ˆæ‰“å•å¼ é£ç‰Œï¼ˆä¸œå—è¥¿åŒ—ï¼‰
            // 2. ç„¶åæ‰“å•å¼ å­—ç‰Œï¼ˆä¸­å‘ç™½ï¼‰
            // 3. ç„¶åæ‰“è¾¹å¼ ï¼ˆ1ã€9ï¼‰å•å¼ 
            // 4. æœ€åéšæœº
            
            const counts = {};
            hand.forEach((tile, index) => {
                const key = tileKey(tile);
                if (!counts[key]) counts[key] = [];
                counts[key].push(index);
            });
            
            // é£ç‰Œé¡ºåºï¼šä¸œå—è¥¿åŒ—
            const fengOrder = ['dong', 'nan', 'xi', 'bei'];
            
            // 1. ä¼˜å…ˆæ‰“å•å¼ é£ç‰Œ
            for (const feng of fengOrder) {
                if (counts[feng] && counts[feng].length === 1) {
                    return counts[feng][0];
                }
            }
            
            // 2. æ‰“å•å¼ å­—ç‰Œï¼ˆä¸­å‘ç™½ï¼‰
            const ziOrder = ['zhong', 'fa', 'bai'];
            for (const zi of ziOrder) {
                if (counts[zi] && counts[zi].length === 1) {
                    return counts[zi][0];
                }
            }
            
            // 3. æ‰“è¾¹å¼ ï¼ˆ1ã€9ï¼‰å•å¼ 
            for (let i = hand.length - 1; i >= 0; i--) {
                const tile = hand[i];
                if (tile.type === 'number' && (tile.value === 1 || tile.value === 9)) {
                    const key = tileKey(tile);
                    if (counts[key].length === 1) {
                        return i;
                    }
                }
            }
            
            // 4. æ‰“ä»»æ„å•å¼ æ•°å­—ç‰Œ
            for (let i = hand.length - 1; i >= 0; i--) {
                const tile = hand[i];
                if (tile.type === 'number') {
                    const key = tileKey(tile);
                    if (counts[key].length === 1) {
                        return i;
                    }
                }
            }
            
            // 5. éšæœºæ‰“ä¸€å¼ ï¼ˆé¿å…æ‰“å¯¹å­ï¼‰
            const singleKeys = Object.keys(counts).filter(k => counts[k].length === 1);
            if (singleKeys.length > 0) {
                const randomKey = singleKeys[Math.floor(Math.random() * singleKeys.length)];
                return counts[randomKey][0];
            }
            
            // å®åœ¨æ²¡åŠæ³•ï¼Œæ‰“æœ€åä¸€å¼ 
            return hand.length - 1;
        }

        // ==================== èƒ¡ç‰Œæ£€æµ‹ ====================
        function checkHu() {
            const hand = [...gameState.players[0].hand];
            
            if (canHu(hand)) {
                const result = calculateFan(hand, true); // true = è‡ªæ‘¸
                const flowerCount = gameState.players[0].flowers.length;
                const flowerBonus = flowerCount * FLOWER_SCORE;
                const baseScore = 10 * Math.pow(2, result.fan);
                const totalScore = (baseScore + flowerBonus) * 3; // è‡ªæ‘¸ä¸‰å®¶ä»˜
                gameState.score += totalScore;
                
                let message = `ä½ èƒ¡äº†ï¼ğŸ‰\n\n`;
                message += `ã€ç•ªå‹ã€‘${result.fanList.join(' + ') || 'åŸºæœ¬èƒ¡'}\n`;
                message += `ã€ç•ªæ•°ã€‘${result.fan}ç•ª\n`;
                message += `ã€åº•åˆ†ã€‘${baseScore}åˆ†\n`;
                message += `ã€èŠ±ç‰Œã€‘${flowerCount}å¼  (+${flowerBonus}åˆ†)\n`;
                message += `ã€è‡ªæ‘¸ã€‘ä¸‰å®¶å„ä»˜ Ã—3\n`;
                message += `â”â”â”â”â”â”â”â”â”â”\n`;
                message += `ã€æ€»å¾—åˆ†ã€‘${totalScore}åˆ†`;
                
                endGame('ğŸŠ æ­å–œèƒ¡ç‰Œï¼', message);
            } else {
                showToast('è¿˜ä¸èƒ½èƒ¡ç‰Œï¼Œç»§ç»­åŠ æ²¹ï¼');
            }
        }

        function canHu(hand, playerIndex = 0) {
            // è€ƒè™‘å‰¯éœ²çš„æƒ…å†µ
            // æœ‰å‰¯éœ²æ—¶ï¼Œæ‰‹ç‰Œ + å‰¯éœ²æ•°*3 åº”è¯¥ = 14
            const player = gameState.players[playerIndex];
            const meldsCount = player ? player.melds.length : 0;
            const expectedHandSize = 14 - meldsCount * 3;
            
            // å…è®¸æœ‰å‰¯éœ²æ—¶æ‰‹ç‰Œå°‘äº14å¼ 
            // ç¢°1ç»„: 14-3=11å¼ , ç¢°2ç»„: 14-6=8å¼ , ç¢°3ç»„: 14-9=5å¼ , ç¢°4ç»„: 14-12=2å¼ 
            if (hand.length !== expectedHandSize && hand.length !== 14) {
                // ä¹Ÿæ¥å—14å¼ ï¼ˆç”¨äºå¬ç‰Œæ£€æµ‹ç­‰ï¼‰
                if (hand.length < 2 || hand.length > 14) return false;
            }
            
            // ä¸ƒå¯¹å­åªèƒ½é—¨æ¸…ï¼ˆæ— å‰¯éœ²ï¼‰
            if (meldsCount === 0 && hand.length === 14 && isQiDui(hand)) return true;
            
            // æ£€æŸ¥åŸºæœ¬å‹ï¼ˆæ‰‹ç‰Œéƒ¨åˆ†çš„é¢å­ + 1é›€å¤´ï¼‰
            // éœ€è¦çš„é¢å­æ•° = (æ‰‹ç‰Œæ•° - 2) / 3
            const needMelds = (hand.length - 2) / 3;
            if (needMelds !== Math.floor(needMelds) || needMelds < 0) return false;
            
            if (isBasicHu(hand)) return true;
            
            return false;
        }

        function isQiDui(hand) {
            const counts = {};
            hand.forEach(tile => {
                const key = tileKey(tile);
                counts[key] = (counts[key] || 0) + 1;
            });
            
            const values = Object.values(counts);
            return values.length === 7 && values.every(v => v === 2);
        }

        function isBasicHu(hand) {
            const counts = {};
            hand.forEach(tile => {
                const key = tileKey(tile);
                counts[key] = (counts[key] || 0) + 1;
            });
            
            // å°è¯•æ¯ç§å¯èƒ½çš„é›€å¤´
            for (const key in counts) {
                if (counts[key] >= 2) {
                    const testCounts = { ...counts };
                    testCounts[key] -= 2;
                    if (testCounts[key] === 0) delete testCounts[key];
                    
                    if (canFormMelds(testCounts)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function canFormMelds(counts) {
            const keys = Object.keys(counts);
            if (keys.length === 0) return true;
            
            // æ’åºï¼šç¡®ä¿æ•°å­—ç‰ŒæŒ‰é¡ºåºå¤„ç†ï¼ˆä»å°åˆ°å¤§ï¼‰ï¼Œè¿™å¯¹é¡ºå­æ£€æµ‹å¾ˆé‡è¦
            keys.sort((a, b) => {
                // æå–èŠ±è‰²å’Œæ•°å­—
                const partsA = a.match(/^(wan|tong|tiao)(\d)$/);
                const partsB = b.match(/^(wan|tong|tiao)(\d)$/);
                
                if (partsA && partsB) {
                    // éƒ½æ˜¯æ•°å­—ç‰Œï¼Œå…ˆæŒ‰èŠ±è‰²æ’åºï¼Œå†æŒ‰æ•°å­—æ’åº
                    if (partsA[1] !== partsB[1]) {
                        return partsA[1].localeCompare(partsB[1]);
                    }
                    return parseInt(partsA[2]) - parseInt(partsB[2]);
                }
                if (partsA) return -1; // æ•°å­—ç‰Œåœ¨å‰
                if (partsB) return 1;
                return a.localeCompare(b); // å­—ç‰ŒæŒ‰å­—æ¯æ’åº
            });
            
            const key = keys[0];
            const count = counts[key];
            
            // å°è¯•ç»„æˆé¡ºå­ï¼ˆä»…é™æ•°å­—ç‰Œï¼Œä¼˜å…ˆå°è¯•é¡ºå­ï¼‰
            const parts = key.match(/^(wan|tong|tiao)(\d)$/);
            if (parts) {
                const suit = parts[1];
                const num = parseInt(parts[2]);
                
                if (num <= 7) {
                    const key2 = `${suit}${num + 1}`;
                    const key3 = `${suit}${num + 2}`;
                    
                    if (counts[key2] && counts[key3]) {
                        const newCounts = { ...counts };
                        newCounts[key]--;
                        newCounts[key2]--;
                        newCounts[key3]--;
                        
                        if (newCounts[key] === 0) delete newCounts[key];
                        if (newCounts[key2] === 0) delete newCounts[key2];
                        if (newCounts[key3] === 0) delete newCounts[key3];
                        
                        if (canFormMelds(newCounts)) return true;
                    }
                }
            }
            
            // å°è¯•ç»„æˆåˆ»å­
            if (count >= 3) {
                const newCounts = { ...counts };
                newCounts[key] -= 3;
                if (newCounts[key] === 0) delete newCounts[key];
                if (canFormMelds(newCounts)) return true;
            }
            
            return false;
        }

        function calculateFan(hand, isSelfDraw = true) {
            let totalFan = 0;
            let fanList = [];
            const player = gameState.players[0];
            const isMenQing = player.melds.length === 0; // é—¨æ¸…ï¼šæ²¡æœ‰ç¢°æ 
            
            // é—¨æ¸… +1ç•ª
            if (isMenQing) {
                totalFan += 1;
                fanList.push('é—¨æ¸…');
            }
            
            // è‡ªæ‘¸ +1ç•ª
            if (isSelfDraw) {
                totalFan += 1;
                fanList.push('è‡ªæ‘¸');
            }
            
            // ä¸ƒå¯¹å­ +2ç•ª
            if (isQiDui(hand)) {
                totalFan += 2;
                fanList.push('ä¸ƒå¯¹å­');
            }
            
            // ç¢°ç¢°èƒ¡ +2ç•ª
            if (isPengPengHu(hand)) {
                totalFan += 2;
                fanList.push('ç¢°ç¢°èƒ¡');
            }
            
            // æ¸…ä¸€è‰² +3ç•ª
            if (isQingYiSe(hand)) {
                totalFan += 3;
                fanList.push('æ¸…ä¸€è‰²');
                
                // æ¸…ç¢°ï¼ˆæ¸…ä¸€è‰²+ç¢°ç¢°èƒ¡ï¼‰é¢å¤–+1ç•ª
                if (isPengPengHu(hand)) {
                    totalFan += 1;
                    fanList.push('æ¸…ç¢°');
                }
            }
            // æ··ä¸€è‰² +2ç•ª
            else if (isHunYiSe(hand)) {
                totalFan += 2;
                fanList.push('æ··ä¸€è‰²');
            }
            
            // æµ·åº•æ +1ç•ªï¼ˆæœ€åä¸€å¼ ç‰Œï¼‰
            if (gameState.deck.length === 0) {
                totalFan += 1;
                fanList.push('æµ·åº•æ');
            }
            
            // å…«èŠ±æŠ¥é“ +8ç•ª
            if (player.flowers.length === 8) {
                totalFan += 8;
                fanList.push('å…«èŠ±æŠ¥é“');
            }
            
            // è‡³å°‘1ç•ª
            if (totalFan === 0) totalFan = 1;
            
            return { fan: totalFan, fanList: fanList };
        }

        // æ£€æµ‹ç¢°ç¢°èƒ¡ï¼ˆå…¨éƒ¨åˆ»å­ï¼‰
        function isPengPengHu(hand) {
            const counts = {};
            hand.forEach(tile => {
                const key = tileKey(tile);
                counts[key] = (counts[key] || 0) + 1;
            });
            
            let pairCount = 0;
            let tripleCount = 0;
            
            for (const key in counts) {
                const count = counts[key];
                if (count === 2) pairCount++;
                else if (count === 3) tripleCount++;
                else if (count === 4) tripleCount++; // 4å¼ å½“ä½œåˆ»å­+1å¼ 
                else if (count === 1) return false; // æœ‰å•å¼ ä¸æ˜¯ç¢°ç¢°èƒ¡
            }
            
            // ç¢°ç¢°èƒ¡ï¼š4ä¸ªåˆ»å­+1å¯¹
            return pairCount === 1 && tripleCount >= 4;
        }

        function isQingYiSe(hand) {
            const suits = new Set();
            let hasHonor = false;
            
            hand.forEach(tile => {
                if (tile.type === 'number') {
                    suits.add(tile.suit);
                } else if (tile.type === 'honor') {
                    hasHonor = true;
                }
            });
            
            return suits.size === 1 && !hasHonor;
        }

        function isHunYiSe(hand) {
            const suits = new Set();
            let hasHonor = false;
            
            hand.forEach(tile => {
                if (tile.type === 'number') {
                    suits.add(tile.suit);
                } else if (tile.type === 'honor') {
                    hasHonor = true;
                }
            });
            
            // æ··ä¸€è‰²ï¼šåªæœ‰ä¸€ç§èŠ±è‰²+å­—ç‰Œ
            return suits.size === 1 && hasHonor;
        }

        // ==================== è¾…åŠ©åŠŸèƒ½ ====================
        function showTips() {
            const hand = gameState.players[0].hand;
            const counts = {};
            
            hand.forEach(tile => {
                const key = tileKey(tile);
                counts[key] = (counts[key] || 0) + 1;
            });
            
            let tips = 'ğŸ’¡ æç¤ºï¼š\n\n';
            
            // å¦‚æœå·²ç»å¬ç‰Œ
            if (gameState.isTing && gameState.tingList) {
                const tingNames = gameState.tingList.map(item => {
                    const display = getTileDisplay(item.tile);
                    return `${display.value}${display.suit}(å‰©${item.remaining}å¼ )`;
                }).join('ã€');
                tips += `ğŸ¯ ã€å·²å¬ç‰Œã€‘å¬ï¼š${tingNames}\n\n`;
                tips += 'âš ï¸ å¬ç‰Œååªèƒ½æ‰“åˆšæ‘¸çš„ç‰Œï¼\n';
            } else {
                // æ‰¾å¯¹å­
                const pairs = Object.entries(counts).filter(([k, v]) => v === 2);
                if (pairs.length >= 1) {
                    tips += `â€¢ ä½ æœ‰ ${pairs.length} å¯¹å¯¹å­\n`;
                }
                
                // æ‰¾åˆ»å­
                const triples = Object.entries(counts).filter(([k, v]) => v >= 3);
                if (triples.length >= 1) {
                    tips += `â€¢ ä½ æœ‰ ${triples.length} ä¸ªåˆ»å­\n`;
                }
                
                // æ£€æŸ¥æ˜¯å¦èƒ½å¬ç‰Œï¼ˆ13å¼ æ—¶ï¼‰
                if (hand.length === 13) {
                    const tingList = checkTingPai(hand);
                    if (tingList && tingList.length > 0) {
                        const tingNames = tingList.map(t => {
                            const display = getTileDisplay(t);
                            return display.value + display.suit;
                        }).join('ã€');
                        tips += `\nğŸ¯ å¯ä»¥å¬ç‰Œï¼å¬ï¼š${tingNames}`;
                    } else {
                        tips += '\nâ€¢ è¿˜æ²¡æœ‰å¬ç‰Œ';
                    }
                } else if (hand.length === 14) {
                    // 14å¼ æ—¶ï¼Œæ£€æŸ¥æ‰“å‡ºå“ªå¼ å¯ä»¥å¬ç‰Œ
                    tips += '\nğŸ” æ£€æŸ¥å“ªå¼ ç‰Œå¯ä»¥å¬ç‰Œ...\n';
                    const tingOptions = [];
                    for (let i = 0; i < hand.length; i++) {
                        const testHand = [...hand];
                        testHand.splice(i, 1);
                        const tingList = checkTingPai(testHand);
                        if (tingList && tingList.length > 0) {
                            const display = getTileDisplay(hand[i]);
                            const tingNames = tingList.map(t => {
                                const d = getTileDisplay(t);
                                return d.value + d.suit;
                            }).slice(0, 3).join('ã€'); // åªæ˜¾ç¤ºå‰3ä¸ª
                            tingOptions.push(`æ‰“${display.value}${display.suit}â†’å¬${tingNames}`);
                        }
                    }
                    if (tingOptions.length > 0) {
                        tips += tingOptions.slice(0, 5).join('\n'); // åªæ˜¾ç¤ºå‰5ä¸ªé€‰æ‹©
                    } else {
                        tips += 'æš‚æ—¶æ²¡æœ‰å¬ç‰Œæœºä¼š';
                    }
                }
            }
            
            showMessage('æ¸¸æˆæç¤º', tips, 'tip');
        }

        function doAction(action) {
            document.getElementById('actionHints').style.display = 'none';
            
            if (action === 'pass') {
                // è¿‡ - ç»§ç»­ä¸‹ä¸€ä¸ªç©å®¶
                continueToNextPlayer();
            } else if (action === 'peng') {
                // ç¢°
                doPeng();
            } else if (action === 'gang') {
                // æ 
                doGang();
            } else if (action === 'hu') {
                // ç‚¹ç‚®èƒ¡
                doDianPaoHu();
            }
        }
        
        // ç»§ç»­åˆ°ä¸‹ä¸€ä¸ªç©å®¶ï¼ˆç©å®¶é€‰æ‹©"è¿‡"åè°ƒç”¨ï¼‰
        function continueToNextPlayer() {
            if (gameState.gameOver) return;
            
            // åŸæœ¬åº”è¯¥è½®åˆ°çš„ä¸‹ä¸€ä¸ªç©å®¶
            gameState.currentPlayer = (gameState.lastDiscardPlayer + 1) % 4;
            gameState.hasDrawn = false;
            
            if (gameState.currentPlayer === 0) {
                playerAutoDrawTile();
            } else {
                setTimeout(() => aiTurn(), 600);
            }
        }

        // ==================== æ¸¸æˆç»“æŸ ====================
        function endGame(title, message) {
            gameState.gameOver = true;
            
            // è¯­éŸ³æ’­æŠ¥
            if (title.includes('èƒ¡') || title.includes('è‡ªæ‘¸')) {
                speakHu();
            } else if (title.includes('æµå±€')) {
                speak('æµå±€', 1.0, 1.0);
            }
            
            // è®¡ç®—æœ¬å±€å„å®¶å¾—åˆ†
            const roundScores = calculateRoundScores(title);
            
            // æ›´æ–°ç§¯åˆ†æ¦œ
            updateScoreboard(title);
            
            // æ˜¾ç¤ºç»“æœã€æœ¬å±€ç§¯åˆ†å’Œæˆ˜ç»©
            const scoreInfo = getScoreboardInfo();
            const fullMessage = message + '\n\n' + roundScores + '\n\n' + scoreInfo;
            
            showMessage(title, fullMessage);
            updateUI();
        }
        
        // è®¡ç®—æœ¬å±€å„å®¶å¾—åˆ†å¹¶ç”Ÿæˆç»“ç®—æ¦œå•
        function calculateRoundScores(result) {
            const players = ['ğŸ‘© ä½ ', 'ğŸ§” ä¸œå®¶', 'ğŸ§” å—å®¶', 'ğŸ§” åŒ—å®¶'];
            const scores = [0, 0, 0, 0];
            const flowers = gameState.players.map(p => p.flowers.length);
            let winnerIndex = -1;
            let loserIndex = -1;
            let isZiMo = false;
            
            if (result.includes('èƒ¡ç‰Œ') || result.includes('è‡ªæ‘¸')) {
                // ç©å®¶èƒ¡ç‰Œ
                winnerIndex = 0;
                isZiMo = result.includes('è‡ªæ‘¸');
                const baseScore = isZiMo ? 3 : 1;
                const flowerBonus = flowers[0];
                const isMenQing = gameState.players[0].melds.length === 0;
                const menQingBonus = isMenQing ? 1 : 0;
                
                const winScore = (baseScore + flowerBonus + menQingBonus) * (isZiMo ? 3 : 1);
                
                if (isZiMo) {
                    scores[0] = winScore;
                    scores[1] = scores[2] = scores[3] = -Math.ceil(winScore / 3);
                } else {
                    scores[0] = winScore;
                    loserIndex = gameState.lastDiscardPlayer;
                    scores[loserIndex] = -winScore;
                }
            } else if (result.includes('AIèƒ¡ç‰Œ')) {
                // AIèƒ¡ç‰Œ
                winnerIndex = gameState.currentPlayer || 1;
                const baseScore = 3;
                scores[winnerIndex] = baseScore + flowers[winnerIndex];
                
                if (gameState.lastDiscardPlayer === 0) {
                    loserIndex = 0;
                    scores[0] = -(baseScore + flowers[winnerIndex]);
                } else if (gameState.lastDiscardPlayer === winnerIndex) {
                    isZiMo = true;
                    for (let i = 0; i < 4; i++) {
                        if (i !== winnerIndex) {
                            scores[i] = -Math.ceil(scores[winnerIndex] / 3);
                        }
                    }
                } else {
                    loserIndex = gameState.lastDiscardPlayer;
                    scores[loserIndex] = -scores[winnerIndex];
                }
            }
            
            // ç”Ÿæˆç»“ç®—æ¦œå•
            let text = 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
            text += 'ğŸ† æœ¬å±€ç»“ç®—æ¦œå• ğŸ†\n';
            text += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n';
            
            // æŒ‰ç§¯åˆ†æ’åºæ˜¾ç¤º
            const rankings = players.map((name, i) => ({
                name, 
                score: scores[i], 
                flowers: flowers[i],
                index: i
            }));
            rankings.sort((a, b) => b.score - a.score);
            
            for (let rank = 0; rank < 4; rank++) {
                const p = rankings[rank];
                const medal = rank === 0 ? 'ğŸ¥‡' : rank === 1 ? 'ğŸ¥ˆ' : rank === 2 ? 'ğŸ¥‰' : '  ';
                const sign = p.score > 0 ? '+' : '';
                const flower = p.flowers > 0 ? ` ğŸŒ¸Ã—${p.flowers}` : '';
                
                // æ·»åŠ ç§°å·
                let title = '';
                if (p.index === winnerIndex) {
                    title = isZiMo ? ' ã€è‡ªæ‘¸ç‹ã€‘' : ' ã€å¤§èµ¢å®¶ã€‘';
                } else if (p.index === loserIndex && !isZiMo) {
                    title = ' ã€æœ€ä½³ç‚®æ‰‹ğŸ’¥ã€‘';
                }
                
                text += `${medal} ${p.name}: ${sign}${p.score}åˆ†${flower}${title}\n`;
            }
            
            text += '\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
            
            // æ·»åŠ ç‰¹æ®Šæˆå°±
            const achievements = [];
            if (winnerIndex === 0) {
                if (isZiMo) achievements.push('ğŸ¯ è‡ªæ‘¸èƒ¡ç‰Œï¼ä¸‰å®¶ä»˜ï¼');
                if (gameState.players[0].melds.length === 0) achievements.push('ğŸšª é—¨æ¸…åŠ ç•ªï¼');
                if (flowers[0] >= 4) achievements.push('ğŸŒ¸ èŠ±ç‰Œå¤§å¸ˆï¼');
            }
            if (loserIndex === 0 && !isZiMo) {
                achievements.push('ğŸ’¥ ä¸å°å¿ƒæ”¾ç‚®äº†...');
            }
            if (result.includes('æµå±€')) {
                achievements.push('ğŸ¤ æœ¬å±€æµå±€ï¼Œä¸‹å±€å†æˆ˜ï¼');
            }
            
            if (achievements.length > 0) {
                text += achievements.join('\n') + '\n';
            }
            
            return text;
        }
        
        // ==================== ç§¯åˆ†æ¦œç³»ç»Ÿ ====================
        
        // ä»localStorageåŠ è½½ç§¯åˆ†
        function loadScoreboard() {
            const saved = localStorage.getItem('mahjong_scoreboard');
            if (saved) {
                return JSON.parse(saved);
            }
            return {
                wins: 0,           // èƒ¡ç‰Œæ¬¡æ•°
                losses: 0,         // è¢«èƒ¡æ¬¡æ•°
                draws: 0,          // æµå±€æ¬¡æ•°
                fangPao: 0,        // æ”¾ç‚®æ¬¡æ•°
                ziMo: 0,           // è‡ªæ‘¸æ¬¡æ•°
                totalScore: 0,     // æ€»ç§¯åˆ†
                maxScore: 0,       // å•å±€æœ€é«˜åˆ†
                gamesPlayed: 0,    // æ€»åœºæ¬¡
                winStreak: 0,      // è¿èƒœ
                maxWinStreak: 0    // æœ€é«˜è¿èƒœ
            };
        }
        
        // ä¿å­˜ç§¯åˆ†
        function saveScoreboard(data) {
            localStorage.setItem('mahjong_scoreboard', JSON.stringify(data));
        }
        
        // æ›´æ–°ç§¯åˆ†æ¦œ
        function updateScoreboard(result) {
            const scoreboard = loadScoreboard();
            scoreboard.gamesPlayed++;
            
            const flowerCount = gameState.players[0].flowers.length;
            const flowerBonus = flowerCount * FLOWER_SCORE;
            
            if (result.includes('èƒ¡ç‰Œ') || result.includes('è‡ªæ‘¸')) {
                // ç©å®¶èƒ¡ç‰Œ
                scoreboard.wins++;
                scoreboard.winStreak++;
                
                if (result.includes('è‡ªæ‘¸')) {
                    scoreboard.ziMo++;
                    scoreboard.totalScore += 10 + flowerBonus; // è‡ªæ‘¸åŸºç¡€10åˆ†
                } else {
                    scoreboard.totalScore += 5 + flowerBonus; // ç‚¹ç‚®åŸºç¡€5åˆ†
                }
                
                if (scoreboard.winStreak > scoreboard.maxWinStreak) {
                    scoreboard.maxWinStreak = scoreboard.winStreak;
                }
                
                const thisScore = (result.includes('è‡ªæ‘¸') ? 10 : 5) + flowerBonus;
                if (thisScore > scoreboard.maxScore) {
                    scoreboard.maxScore = thisScore;
                }
            } else if (result.includes('AIèƒ¡ç‰Œ')) {
                // AIèƒ¡ç‰Œï¼Œç©å®¶è¾“
                scoreboard.losses++;
                scoreboard.winStreak = 0;
                scoreboard.totalScore -= 5;
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯ç©å®¶æ”¾ç‚®
                if (gameState.lastDiscardPlayer === 0) {
                    scoreboard.fangPao++;
                }
            } else if (result.includes('æµå±€')) {
                // æµå±€
                scoreboard.draws++;
                // è¿èƒœä¸ä¸­æ–­
            }
            
            saveScoreboard(scoreboard);
        }
        
        // è·å–ç§¯åˆ†æ¦œä¿¡æ¯
        function getScoreboardInfo() {
            const s = loadScoreboard();
            const winRate = s.gamesPlayed > 0 ? Math.round(s.wins / s.gamesPlayed * 100) : 0;
            
            return `ğŸ“Š æˆ˜ç»©ç»Ÿè®¡\n` +
                   `èƒœ${s.wins} è´Ÿ${s.losses} å¹³${s.draws} | èƒœç‡${winRate}%\n` +
                   `æ€»ç§¯åˆ†: ${s.totalScore} | è¿èƒœ: ${s.winStreak}`;
        }
        
        // æ˜¾ç¤ºå®Œæ•´ç§¯åˆ†æ¦œ
        function showFullScoreboard() {
            const s = loadScoreboard();
            const winRate = s.gamesPlayed > 0 ? Math.round(s.wins / s.gamesPlayed * 100) : 0;
            
            const info = 
                `ğŸ† ç§¯åˆ†æ¦œ\n\n` +
                `ğŸ“ˆ æ€»ç§¯åˆ†: ${s.totalScore}\n` +
                `ğŸ® æ€»åœºæ¬¡: ${s.gamesPlayed}\n\n` +
                `âœ… èƒœåœº: ${s.wins} (èƒœç‡${winRate}%)\n` +
                `âŒ è´Ÿåœº: ${s.losses}\n` +
                `â– æµå±€: ${s.draws}\n\n` +
                `ğŸ€„ è‡ªæ‘¸æ¬¡æ•°: ${s.ziMo}\n` +
                `ğŸ’¥ æ”¾ç‚®æ¬¡æ•°: ${s.fangPao}\n\n` +
                `ğŸ”¥ å½“å‰è¿èƒœ: ${s.winStreak}\n` +
                `ğŸ‘‘ æœ€é«˜è¿èƒœ: ${s.maxWinStreak}\n` +
                `â­ å•å±€æœ€é«˜åˆ†: ${s.maxScore}`;
            
            showMessage('ğŸ† ç§¯åˆ†æ¦œ', info, 'tip');
        }
        
        // é‡ç½®ç§¯åˆ†æ¦œ
        function resetScoreboard() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æˆ˜ç»©å—ï¼Ÿ')) {
                localStorage.removeItem('mahjong_scoreboard');
                showToast('æˆ˜ç»©å·²æ¸…ç©º');
            }
        }

        // ==================== UIè¾…åŠ© ====================
        // showMessage å¢åŠ  modalType å‚æ•°ï¼Œæ§åˆ¶æŒ‰é’®æ˜¾ç¤º
        // modalType: 'result' = æ¸¸æˆç»“æœ(ç»§ç»­ä¸‹ä¸€å±€), 'start' = æ¸¸æˆå¼€å§‹, 'ting' = å¬ç‰Œæç¤º, 'tip' = æ™®é€šæç¤º
        function showMessage(title, message, modalType = 'result') {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;
            
            // æ ¹æ®ç±»å‹æ˜¾ç¤ºä¸åŒæŒ‰é’®
            const modalButtons = document.getElementById('modalButtons');
            const startGameButtons = document.getElementById('startGameButtons');
            const tingButtons = document.getElementById('tingButtons');
            const modal = document.getElementById('modal');
            
            // éšè—æ‰€æœ‰æŒ‰é’®åŒº
            modalButtons.style.display = 'none';
            startGameButtons.style.display = 'none';
            tingButtons.style.display = 'none';
            
            // ç§»é™¤ä¹‹å‰çš„ç‚¹å‡»å…³é—­äº‹ä»¶
            modal.onclick = null;
            
            if (modalType === 'start' || modalType === true) {
                // æ¸¸æˆå¼€å§‹ï¼šåªæ˜¾ç¤º"å¼€å§‹å‡ºç‰Œ"æŒ‰é’®
                startGameButtons.style.display = 'block';
            } else if (modalType === 'ting' || modalType === 'tip') {
                // å¬ç‰Œ/æç¤ºï¼šç‚¹å‡»ä»»æ„ä½ç½®å…³é—­
                tingButtons.style.display = 'block';
                modal.onclick = function(e) {
                    closeModal();
                    modal.onclick = null;
                };
            } else {
                // æ¸¸æˆç»“æŸ(result)ï¼šæ˜¾ç¤º"ç»§ç»­ä¸‹ä¸€å±€"å’Œ"è¿”å›èœå•"
                modalButtons.style.display = 'flex';
            }
            
            modal.classList.add('active');
        }

        function closeModal() {
            document.getElementById('modal').classList.remove('active');
        }
        
        // ç»§ç»­ä¸‹ä¸€å±€ï¼ˆä¿æŒå½“å‰éš¾åº¦ï¼‰
        function continueNextRound() {
            closeModal();
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€ä½†ä¿ç•™éš¾åº¦å’Œç§¯åˆ†
            const currentDifficulty = gameState.difficulty;
            const currentRound = gameState.round || 1;
            
            gameState.deck = createDeck();
            gameState.gameOver = false;
            gameState.currentPlayer = 0;
            gameState.selectedTile = -1;
            gameState.hasDrawn = false;
            gameState.lastDiscard = null;
            gameState.lastDiscardPlayer = -1;
            gameState.round = currentRound + 1;
            gameState.isTing = false;
            gameState.tingList = null;
            
            // æ¸…ç©ºæ‰€æœ‰ç©å®¶æ‰‹ç‰Œä½†ä¿ç•™ç§¯åˆ†
            gameState.players.forEach(player => {
                player.hand = [];
                player.melds = [];
                player.discards = [];
                player.flowers = [];
            });
            
            // é‡æ–°å‘ç‰Œ
            for (let i = 0; i < 13; i++) {
                gameState.players.forEach((player, playerIndex) => {
                    drawAndCheckFlower(playerIndex);
                });
            }
            
            // ç©å®¶å¤šæ‘¸ä¸€å¼ ï¼ˆ14å¼ ï¼‰
            drawAndCheckFlower(0);
            
            // ç†ç‰Œ
            gameState.players.forEach(player => {
                player.hand.sort((a, b) => {
                    if (a.type !== b.type) {
                        const order = { wan: 1, tong: 2, tiao: 3, honor: 4 };
                        return (order[a.type] || 5) - (order[b.type] || 5);
                    }
                    return a.value - b.value;
                });
            });
            
            gameState.hasDrawn = true;
            updateUI();
            showToast(`ç¬¬ ${gameState.round} å±€å¼€å§‹ï¼`);
        }
        
        // å…³é—­å¼¹çª—å¹¶è¿”å›èœå•
        function closeModalAndBack() {
            closeModal();
            backToMenu();
        }
        
        // å‘ç‰Œæ—¶æ£€æŸ¥èŠ±ç‰Œå¹¶è¡¥èŠ±
        function drawAndCheckFlower(playerIndex) {
            if (gameState.deck.length === 0) return;
            
            let tile = gameState.deck.pop();
            
            // å¦‚æœæ˜¯èŠ±ç‰Œï¼Œæ”¾å…¥èŠ±ç‰ŒåŒºå¹¶ç»§ç»­æ‘¸
            while (isFlowerTile(tile) && gameState.deck.length > 0) {
                gameState.players[playerIndex].flowers.push(tile);
                tile = gameState.deck.pop();
            }
            
            if (!isFlowerTile(tile)) {
                gameState.players[playerIndex].hand.push(tile);
            } else {
                gameState.players[playerIndex].flowers.push(tile);
            }
        }

        function showToast(message, duration = 2000) {
            const toast = document.createElement('div');
            const animDuration = duration / 1000;
            toast.style.cssText = `
                position: fixed;
                top: 20%;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 15px 30px;
                border-radius: 10px;
                z-index: 2000;
                animation: fadeInOut ${animDuration}s ease forwards;
                font-size: 1.2rem;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => toast.remove(), duration);
        }

        function showRules() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('rulesContainer').classList.add('active');
        }

        function hideRules() {
            document.getElementById('rulesContainer').classList.remove('active');
            document.getElementById('startScreen').style.display = 'flex';
        }

        function backToMenu() {
            if (!gameState.gameOver && gameState.deck.length > 0) {
                if (!confirm('ç¡®å®šè¦é€€å‡ºå½“å‰æ¸¸æˆå—ï¼Ÿ')) return;
            }
            
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            gameState.gameOver = true;
        }

        // æ·»åŠ CSSåŠ¨ç”»
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeInOut {
                0% { opacity: 0; transform: translate(-50%, 10px); }
                20% { opacity: 1; transform: translate(-50%, 0); }
                80% { opacity: 1; transform: translate(-50%, 0); }
                100% { opacity: 0; transform: translate(-50%, -10px); }
            }
        `;
        document.head.appendChild(style);

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver) return;
            
            if (e.code === 'Space') {
                e.preventDefault();
                if (!gameState.hasDrawn) {
                    drawTile();
                } else if (gameState.selectedTile !== -1) {
                    discardSelected();
                }
            }
            
            if (e.code === 'KeyS') {
                sortHand();
            }
        });
        
        // é¡µé¢åŠ è½½æ—¶æ˜¾ç¤ºç§¯åˆ†æ¦œæ¦‚è§ˆ
        function initScoreboardPreview() {
            const s = loadScoreboard();
            const winRate = s.gamesPlayed > 0 ? Math.round(s.wins / s.gamesPlayed * 100) : 0;
            
            const preview = document.getElementById('scoreboardPreview');
            if (preview) {
                if (s.gamesPlayed === 0) {
                    preview.innerHTML = `ğŸ† è¿˜æ²¡æœ‰æˆ˜ç»©ï¼Œå¼€å§‹ç¬¬ä¸€å±€å§ï¼`;
                } else {
                    preview.innerHTML = 
                        `ğŸ† æ€»ç§¯åˆ†: <span class="score-big">${s.totalScore}</span> ` +
                        `| èƒœ${s.wins} è´Ÿ${s.losses} å¹³${s.draws} ` +
                        `| èƒœç‡${winRate}% ` +
                        `${s.winStreak > 0 ? 'ğŸ”¥' + s.winStreak + 'è¿èƒœ' : ''}`;
                }
            }
        }
        
        // åˆå§‹åŒ–
        initScoreboardPreview();
    </script>
</body>
</html>
